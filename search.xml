<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>rootfs</title>
    <url>/2020/03/07/rootfs/</url>
    <content><![CDATA[<h1 id="容器创建中rootfs的蜕变之路"><a href="#容器创建中rootfs的蜕变之路" class="headerlink" title="容器创建中rootfs的蜕变之路"></a>容器创建中rootfs的蜕变之路</h1><p>待续</p>
]]></content>
  </entry>
  <entry>
    <title>magic_create</title>
    <url>/2020/03/07/magic_create/</url>
    <content><![CDATA[<hr>
<p>作者： haozi007  日期：2020-02-15</p>
<hr>
<h1 id="骚气的容器创建流程"><a href="#骚气的容器创建流程" class="headerlink" title="骚气的容器创建流程"></a>骚气的容器创建流程</h1><p>runc create的流程，包含不少骚气的操作，我们首先把大体流程梳理清楚，然后慢慢探索这些细节。</p>
<pre class="mermaid">graph LR
main.go --> createCommand
createCommand --> revisePidFile
createCommand --> setupSpec
createCommand --> startContainer
createCommand --> Exit
setupSpec --> loadSpec
startContainer --> newNotifySocket
startContainer --> createContainer
startContainer --> setupSocket
startContainer --> runner.run.CT_ACT_CREATE</pre>

<h2 id="createContainer"><a href="#createContainer" class="headerlink" title="createContainer"></a>createContainer</h2><p>负责创建libcontainer.Container结构体，并且设置容器的相关配置。主要流程如下：</p>
<ol>
<li><p>把oci spec转换为libcontainer能识别的配置结构体configs.Config</p>
</li>
<li><p>loadFactory中，初始化了cgroup的manager</p>
</li>
<li><p>loadFactory中，创建linuxFactory，<strong>注意InitPath和InitArgs的值</strong>，如何从runc create拉起runc init进程的关键点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">LinuxFactory&#123;</span><br><span class="line">		Root:      root,</span><br><span class="line">		InitPath:  <span class="string">"/proc/self/exe"</span>,</span><br><span class="line">		InitArgs:  []<span class="keyword">string</span>&#123;os.Args[<span class="number">0</span>], <span class="string">"init"</span>&#125;,</span><br><span class="line">		Validator: validate.New(),</span><br><span class="line">		CriuPath:  <span class="string">"criu"</span>,</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建linuxContainer</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">linuxContainer&#123;</span><br><span class="line">		id:            id,</span><br><span class="line">		root:          containerRoot,</span><br><span class="line">		config:        config,</span><br><span class="line">		initPath:      l.InitPath,</span><br><span class="line">		initArgs:      l.InitArgs,</span><br><span class="line">		criuPath:      l.CriuPath,</span><br><span class="line">		newuidmapPath: l.NewuidmapPath,</span><br><span class="line">		newgidmapPath: l.NewgidmapPath,</span><br><span class="line">		cgroupManager: l.NewCgroupsManager(config.Cgroups, <span class="literal">nil</span>),</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>创建的容器的initPath和initArgs分别为”/proc/self/exe”和“init”，在后续的流程中会体会到其作用。</p>
</li>
</ol>
<h2 id="runner-run"><a href="#runner-run" class="headerlink" title="runner.run"></a>runner.run</h2><p>首先看看utils_linux.go的runner结构体。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> runner <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 标识启动的进程是否为容器的1号进程</span></span><br><span class="line">	init            <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// 标识当前进程作为子孙进程的收割进程（作用等价于1号进程）</span></span><br><span class="line">	enableSubreaper <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// 标识是否需要清理动作，删除cgroup、poststop hooks等等</span></span><br><span class="line">	shouldDestroy   <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// 标识是否以分离方式运行容器</span></span><br><span class="line">	detach          <span class="keyword">bool</span></span><br><span class="line">	listenFDs       []*os.File</span><br><span class="line">	preserveFDs     <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// pid文件路径</span></span><br><span class="line">	pidFile         <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// 用于接收console伪终端的master，是一个AF_UNIX的socket路径</span></span><br><span class="line">	consoleSocket   <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// 上一步创建的container结构体</span></span><br><span class="line">	container       libcontainer.Container</span><br><span class="line">	<span class="comment">// runner的操作类型</span></span><br><span class="line">	action          CtAct</span><br><span class="line">	<span class="comment">// 用于notify的socket文件</span></span><br><span class="line">	notifySocket    *notifySocket</span><br><span class="line">	<span class="comment">// CRIU相关配置</span></span><br><span class="line">	criuOpts        *libcontainer.CriuOpts</span><br><span class="line">	<span class="comment">// 日志级别</span></span><br><span class="line">	logLevel        <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行runner的操作，支持CREATE，RESTORE，RUN</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *runner)</span> <span class="title">run</span><span class="params">(config *specs.Process)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行容器的清理动作，根据状态执行对应操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *runner)</span> <span class="title">destroy</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 终止容器进程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *runner)</span> <span class="title">terminate</span><span class="params">(p *libcontainer.Process)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查终端，console和detach配置是否正确</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *runner)</span> <span class="title">checkTerminal</span><span class="params">(config *specs.Process)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<p>run()函数中，主要是准备一个libcontainer.Process，用于传递linuxContainer.Start流程。</p>
<p>大体流程如下</p>
<pre class="mermaid">graph LR
run-->prepare
prepare-->checkTerminal
prepare-->newProcess
prepare-->append-ExtraFiles
prepare-->set-uid-gid
prepare-->newSignalHandler
prepare-->setupIO
prepare-->container.Start</pre>

<h3 id="准备的process"><a href="#准备的process" class="headerlink" title="准备的process"></a>准备的process</h3><p>主要包括几个方面：</p>
<ol>
<li>newProcess创建结构体，并且初始化容器的配置到该结构体；</li>
<li>添加拓展的fd到该结构体的ExtraFiles，以及设置LISTEN_FDS的环境变量；</li>
<li>设置uid，gid；</li>
<li>初始化信号处理函数；</li>
<li>设置io</li>
</ol>
<h3 id="container-Start"><a href="#container-Start" class="headerlink" title="container-Start"></a>container-Start</h3><p>第一步，创建execFIFO，这个FIFO文件的作用是，用于控制执行容器首进程的。在exec容器的首进程之前，会先往这个FIFO文件写入一个“0”字节，如果没有人打开这个FIFO，会导致写阻塞。因此，runc的start命令很简单，就是打开这个FIFO即可。</p>
<h4 id="newParentProcess函数"><a href="#newParentProcess函数" class="headerlink" title="newParentProcess函数"></a>newParentProcess函数</h4><p>最关键的一步，创建启动容器的process。</p>
<pre class="mermaid">graph LR
newParentProcess-->commandTemplate
newParentProcess-->includeExecFifo
newParentProcess-->newInitProcess</pre>

<p>commandTemplate函数，准备了运行的process的exec.Cmd结构体，比较感觉的几个配置，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 记得上文中提到的关注点吗？这里的initPath为&quot;&#x2F;proc&#x2F;self&#x2F;exe&quot;，而initArgs[1]为&quot;init&quot;</span><br><span class="line">cmd :&#x3D; exec.Command(c.initPath, c.initArgs[1:]...)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过环境变量，传递INITPIPE的句柄，在nsenter模块中将会使用</span><br><span class="line">cmd.Env &#x3D; append(cmd.Env,</span><br><span class="line">		fmt.Sprintf(&quot;_LIBCONTAINER_INITPIPE&#x3D;%d&quot;, stdioFdCount+len(cmd.ExtraFiles)-1),</span><br><span class="line">		fmt.Sprintf(&quot;_LIBCONTAINER_STATEDIR&#x3D;%s&quot;, c.root),</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过环境变量，传递LOGPIPE的句柄，在nsenter模块中将会使用</span><br><span class="line">cmd.Env &#x3D; append(cmd.Env,</span><br><span class="line">		fmt.Sprintf(&quot;_LIBCONTAINER_LOGPIPE&#x3D;%d&quot;, stdioFdCount+len(cmd.ExtraFiles)-1),</span><br><span class="line">		fmt.Sprintf(&quot;_LIBCONTAINER_LOGLEVEL&#x3D;%s&quot;, p.LogLevel),</span><br><span class="line">	)</span><br></pre></td></tr></table></figure>

<p>includeExecFifo函数，通过环境变量传递execFIFO句柄</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd.Env &#x3D; append(cmd.Env,</span><br><span class="line">		fmt.Sprintf(&quot;_LIBCONTAINER_FIFOFD&#x3D;%d&quot;, stdioFdCount+len(cmd.ExtraFiles)-1))</span><br></pre></td></tr></table></figure>

<p>newInitProcess函数，设置初始化类型、设置bootstrap数据（nsenter模块设置的相关数据）、以及创建initProcess结构体</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">initProcess&#123;</span><br><span class="line">		cmd:             cmd,</span><br><span class="line">		messageSockPair: messageSockPair,</span><br><span class="line">		logFilePair:     logFilePair,</span><br><span class="line">		manager:         c.cgroupManager,</span><br><span class="line">		intelRdtManager: c.intelRdtManager,</span><br><span class="line">		config:          c.newInitConfig(p),</span><br><span class="line">		container:       c,</span><br><span class="line">		process:         p,</span><br><span class="line">		bootstrapData:   data,</span><br><span class="line">		sharePidns:      sharePidns,</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="启动initProcess"><a href="#启动initProcess" class="headerlink" title="启动initProcess"></a>启动initProcess</h4><p>第一步，就是启动commandTemplate返回的Cmd，也就是通过exec启动了一个新的进程，而该进程的二进制为”/proc/self/exe”，表示当前进程的二进制，也就是runc，而第一个参数为init。因此，相当于执行了”runc init”。</p>
<p>那么，现在的程序结构如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Title: runc create start init process</span><br><span class="line">create-&gt;init: start new process</span><br><span class="line">Note left of create: apply cgroup sets to init.pid</span><br><span class="line">create-&gt;init: send bootstrap data to init</span><br><span class="line">init-&gt;init: get bootstrap data, and do some works</span><br><span class="line">create-&gt;create: wait child pids, and wait first child finish</span><br><span class="line">init-&gt;create: send child and grand child pids</span><br><span class="line">Note left of create: apply cgroup sets to child.pid</span><br><span class="line">create-&gt;init: send sync message -- creatCgroupns</span><br><span class="line">create-&gt;create: wait grand child finish</span><br><span class="line">Note left of create: create network interface</span><br><span class="line">create-&gt;init: send config data</span><br><span class="line">create-&gt;create: wait sync message</span><br><span class="line">Note right of init: ... now is runc init go codes...</span><br><span class="line">init-&gt;init: get config data, do many works...</span><br><span class="line">init-&gt;create: send sync message -- procReady</span><br><span class="line">create-&gt;create: 1. set cgroup sets;2. run preStart hooks</span><br><span class="line">create-&gt;init: send sync message -- procRun</span><br><span class="line">Note left of create: another sync message is procHooks</span><br><span class="line">create-&gt;create: wait init pipe closed</span><br><span class="line">Note left of create: 1. update state of container, 2. run postStart hooks</span><br><span class="line">Note left of create: finish</span><br></pre></td></tr></table></figure>



<p>init进程的操作分为两部分：</p>
<ol>
<li>第一部分，在nsenter中，执行double fork，设置namespace等相关操作；</li>
<li>第二部分，在init代码中，后续将进行详细分析。</li>
</ol>
<p>从send config data开始，为第二部分的操作了。</p>
<pre class="mermaid">graph LR
Init --> 配置网络
Init --> prepareRootfs
Init --> CreateConsole
Init --> finalizeRootfs
Init --> ApplyProfile
Init --> Readonly-And-Mask-Paths
Init --> syncParentReady
Init --> SetProcessLabel
Init --> InitSeccomp
Init --> finalizeNamespace
Init --> close-pipe-to-notify-init-complete
Init --> open-and-write-exec-fifo-to-wait-runc-start
Init --> exec-container-init-process</pre>

<h5 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h5><p>涉及两个部分：</p>
<ol>
<li>设置loop网络</li>
<li>设置路由信息</li>
</ol>
<h5 id="prepareRootfs"><a href="#prepareRootfs" class="headerlink" title="prepareRootfs"></a>prepareRootfs</h5><p>传播属性的概念参考<a href="https://www.missshi.cn/api/view/blog/5d117ab6ef3ee940b7000000" target="_blank" rel="noopener">文章</a>。</p>
<blockquote>
<p>peer group就是一个或多个挂载点的集合，他们之间可以共享挂载信息。<br>目前在下面两种情况下会使两个挂载点属于同一个peer group（前提条件是挂载点的propagation type是shared）</p>
<ol>
<li>利用mount –bind命令，将会使源和目的挂载点属于同一个peer group，当然前提条件是”源”必须要是一个挂载点。</li>
<li>当创建新的mount namespace时，新namespace会拷贝一份老namespace的挂载点信息，于是新的和老的namespace里面的相同挂载点就会属于同一个peer group。</li>
</ol>
<p>每个挂载点都有一个propagation type标志, 由它来决定当一个挂载点的下面创建和移除挂载点的时候，是否会传播到属于相同peer group的其他挂载点下去，也即同一个peer group里的其他的挂载点下面是不是也会创建和移除相应的挂载点。现在有4种不同类型的propagation type：</p>
<ol>
<li>MS_SHARED: 从名字就可以看出，挂载信息会在同一个peer group的不同挂载点之间共享传播. 当一个挂载点下面添加或者删除挂载点的时候，同一个peer group里的其他挂载点下面也会挂载和卸载同样的挂载点。</li>
<li>MS_PRIVATE: 跟上面的刚好相反，挂载信息根本就不共享，也即private的挂载点不会属于任何peer group。</li>
<li>MS_SLAVE: 跟名字一样，信息的传播是单向的，在同一个peer group里面，master的挂载点下面发生变化的时候，slave的挂载点下面也跟着变化，但反之则不然，slave下发生变化的时候不会通知master，master不会发生变化。</li>
<li>MS_UNBINDABLE: 这个和MS_PRIVATE相同，只是这种类型的挂载点不能作为bind mount的源，主要用来防止递归嵌套情况的出现。这种类型不常见，本篇将不介绍这种类型。</li>
</ol>
<p>Ps：需要补充说明的是：</p>
<ol>
<li>propagation type是挂载点的属性，每个挂载点都是独立的。</li>
<li>挂载点是有父子关系的，比如挂载点/和/mnt/cdrom，/mnt/cdrom都是”/”的子挂载点，”/”是/mnt/cdrom的父挂载点。</li>
<li>默认情况下，如果父挂载点是MS_SHARED，那么子挂载点也是MS_SHARED的，否则子挂载点将会是MS_PRIVATE，跟祖父级别挂载点没有关系。</li>
</ol>
</blockquote>
<p>因此，runc首先对容器namespace的根目录的propagation type(传播属性)。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepareRoot</span><span class="params">(config *configs.Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	flag := unix.MS_SLAVE | unix.MS_REC</span><br><span class="line">	<span class="keyword">if</span> config.RootPropagation != <span class="number">0</span> &#123;</span><br><span class="line">		flag = config.RootPropagation</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := unix.Mount(<span class="string">""</span>, <span class="string">"/"</span>, <span class="string">""</span>, <span class="keyword">uintptr</span>(flag), <span class="string">""</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Make parent mount private to make sure following bind mount does</span></span><br><span class="line">	<span class="comment">// not propagate in other namespaces. Also it will help with kernel</span></span><br><span class="line">	<span class="comment">// check pass in pivot_root. (IS_SHARED(new_mnt-&gt;mnt_parent))</span></span><br><span class="line">	<span class="keyword">if</span> err := rootfsParentMountPrivate(config.Rootfs); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> unix.Mount(config.Rootfs, config.Rootfs, <span class="string">"bind"</span>, unix.MS_BIND|unix.MS_REC, <span class="string">""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>nsenter</title>
    <url>/2020/03/07/nsenter/</url>
    <content><![CDATA[<hr>
<p>作者： haozi007  日期：2020-02-15</p>
<hr>
<h1 id="nsenter模块分析"><a href="#nsenter模块分析" class="headerlink" title="nsenter模块分析"></a>nsenter模块分析</h1><p>nsenter模块，主要涉及namespace管理（把当前进程加入到指定的namespace或者创建新的namespace）、uid和gid的映射管理以及串口的管理等。</p>
<p>涉及golang和c两种语言实现，具体实现代码：</p>
<p>libcontainer/nsenter， 核心实现在libcontainer/nsenter/nsexec.c。</p>
<h2 id="模块入口"><a href="#模块入口" class="headerlink" title="模块入口"></a>模块入口</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> nsenter</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#cgo CFLAGS: -Wall</span></span><br><span class="line"><span class="comment">extern void nsexec();</span></span><br><span class="line"><span class="comment">void __attribute__((constructor)) init(void) &#123;</span></span><br><span class="line"><span class="comment">	nsexec();</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"C"</span></span><br></pre></td></tr></table></figure>

<p>当有包<code>import _ &quot;github.com/opencontainers/runc/libcontainer/nsenter&quot;</code>的时候，会导致C语言实现的部分在编译的时候，编译到对应的可执行文件中。而这里的C代码，定义了一个构造函数<code>init(void)</code>，从C语言的构造函数特性，可以了解到，构造函数会在main函数执行之前运行。那么，<code>init(void)</code>函数会在可执行文件一开始就运行。所以，<code>nsexec()</code>函数会第一个执行。</p>
<h2 id="nsexec函数"><a href="#nsexec函数" class="headerlink" title="nsexec函数"></a>nsexec函数</h2><p>主要功能如下：</p>
<ol>
<li>设置log pipe，用于日志传输；</li>
<li>设置init pipe，用于namespace等配置数据的传输以及子进程pid的回传；</li>
<li>ensure clone binary，用于解决<em>CVE-2019-5736</em>，防止/proc/self/exe导致的安全漏洞；</li>
<li>读取并解析init pipe传入的namespace等数据信息；</li>
<li>更新oom配置；</li>
<li>执行double fork</li>
</ol>
<h3 id="ensure-clone-binary"><a href="#ensure-clone-binary" class="headerlink" title="ensure clone binary"></a>ensure clone binary</h3><p>在第一次运行时，拷贝原始的二进制文件内容到内存。后续的二进制执行，都是使用的内存数据。从而消除，运行过程中二进制被修改，导致的安全漏洞。</p>
<p>具体实现待分析：clone_binary.c — ensure_cloned_binary()</p>
<h3 id="double-clone"><a href="#double-clone" class="headerlink" title="double clone"></a>double clone</h3><p>nsexec中，进行了2次clone进程。</p>
<p>至于为何需要进行2次clone操作的原因，可以参考注释：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">	 * Okay, so this is quite annoying.</span><br><span class="line">	 *</span><br><span class="line">	 * In order for this unsharing code to be more extensible we need to split</span><br><span class="line">	 * up unshare(CLONE_NEWUSER) and clone() in various ways. The ideal case</span><br><span class="line">	 * would be if we did clone(CLONE_NEWUSER) and the other namespaces</span><br><span class="line">	 * separately, but because of SELinux issues we cannot really do that. But</span><br><span class="line">	 * we cannot just dump the namespace flags into clone(...) because several</span><br><span class="line">	 * usecases (such as rootless containers) require more granularity around</span><br><span class="line">	 * the namespace setup. In addition, some older kernels had issues where</span><br><span class="line">	 * CLONE_NEWUSER wasn&#39;t handled before other namespaces (but we cannot</span><br><span class="line">	 * handle this while also dealing with SELinux so we choose SELinux support</span><br><span class="line">	 * over broken kernel support).</span><br><span class="line">	 *</span><br><span class="line">	 * However, if we unshare(2) the user namespace *before* we clone(2), then</span><br><span class="line">	 * all hell breaks loose.</span><br><span class="line">	 *</span><br><span class="line">	 * The parent no longer has permissions to do many things (unshare(2) drops</span><br><span class="line">	 * all capabilities in your old namespace), and the container cannot be set</span><br><span class="line">	 * up to have more than one &#123;uid,gid&#125; mapping. This is obviously less than</span><br><span class="line">	 * ideal. In order to fix this, we have to first clone(2) and then unshare.</span><br><span class="line">	 *</span><br><span class="line">	 * Unfortunately, it&#39;s not as simple as that. We have to fork to enter the</span><br><span class="line">	 * PID namespace (the PID namespace only applies to children). Since we&#39;ll</span><br><span class="line">	 * have to double-fork, this clone_parent() call won&#39;t be able to get the</span><br><span class="line">	 * PID of the _actual_ init process (without doing more synchronisation than</span><br><span class="line">	 * I can deal with at the moment). So we&#39;ll just get the parent to send it</span><br><span class="line">	 * for us, the only job of this process is to update</span><br><span class="line">	 * &#x2F;proc&#x2F;pid&#x2F;&#123;setgroups,uid_map,gid_map&#125;.</span><br><span class="line">	 *</span><br><span class="line">	 * And as a result of the above, we also need to setns(2) in the first child</span><br><span class="line">	 * because if we join a PID namespace in the topmost parent then our child</span><br><span class="line">	 * will be in that namespace (and it will not be able to give us a PID value</span><br><span class="line">	 * that makes sense without resorting to sending things with cmsg).</span><br><span class="line">	 *</span><br><span class="line">	 * This also deals with an older issue caused by dumping cloneflags into</span><br><span class="line">	 * clone(2): On old kernels, CLONE_PARENT didn&#39;t work with CLONE_NEWPID, so</span><br><span class="line">	 * we have to unshare(2) before clone(2) in order to do this. This was fixed</span><br><span class="line">	 * in upstream commit 1f7f4dde5c945f41a7abc2285be43d918029ecc5, and was</span><br><span class="line">	 * introduced by 40a0d32d1eaffe6aac7324ca92604b6b3977eb0e. As far as we&#39;re</span><br><span class="line">	 * aware, the last mainline kernel which had this bug was Linux 3.12.</span><br><span class="line">	 * However, we cannot comment on which kernels the broken patch was</span><br><span class="line">	 * backported to.</span><br><span class="line">	 *</span><br><span class="line">	 * -- Aleksa &quot;what has my life come to?&quot; Sarai</span><br><span class="line">	 *&#x2F;</span><br></pre></td></tr></table></figure>

<p>包括父进程在内，一共涉及了3个进程，它们的关系序列如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Title: How to clone init process</span><br><span class="line">Parent-&gt;Child: clone first child</span><br><span class="line">Note right of Child:  join namespace and unshare newuser</span><br><span class="line">Child-&gt;Parent: send SYNC_USERMAP_PLS</span><br><span class="line">Note left of Parent: update groups,uid and gid</span><br><span class="line">Parent-&gt;Child: send SYNC_USERMAP_ACK</span><br><span class="line">Note right of Child: unshare other namespace, except cgroup</span><br><span class="line">Child-&gt;GrandChild: clone grand child</span><br><span class="line">Child-&gt;Parent: send SYNC_RECVPID_PLS</span><br><span class="line">Note left of Parent: get pid of childs</span><br><span class="line">Parent-&gt;Child: send SYNC_RECVPID_ACK</span><br><span class="line">Note left of Parent: send pid of childs to parent of myself(process of runc create)</span><br><span class="line">Child-&gt;Parent: send SYNC_CHILD_READY</span><br><span class="line">Note right of Child: finish</span><br><span class="line">Parent-&gt;GrandChild: send SYNC_GRANDCHILD</span><br><span class="line">Note left of Parent: wait SYNC_CHILD_READY from GrandChild</span><br><span class="line">Note right of GrandChild: set sid,uid,gid</span><br><span class="line">Note right of GrandChild: unshare cgroup namespace</span><br><span class="line">GrandChild-&gt;Parent: send SYNC_CHILD_READY</span><br><span class="line">Note left of Parent: finish</span><br><span class="line">Note right of GrandChild: let go runtime take over process</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>Hexo搭建GitPage静态博客</title>
    <url>/2018/01/21/hexo_on_gitpage/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul>
<li>docker</li>
<li>nodejs镜像</li>
<li>hexo</li>
<li>git相关</li>
</ul>
<h3 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h3><p>docker的安装请参考官方文档：<a href="https://docs.docker.com/engine/installation/" target="_blank" rel="noopener">https://docs.docker.com/engine/installation/</a></p>
<h3 id="nodejs镜像"><a href="#nodejs镜像" class="headerlink" title="nodejs镜像"></a>nodejs镜像</h3><p>国内可以使用Docker官方的加速地址，具体配置参考官方文档： <a href="https://www.docker-cn.com/registry-mirror" target="_blank" rel="noopener">https://www.docker-cn.com/registry-mirror</a></p>
<p>本文使用修改config的方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后下载nodejs的官方镜像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull node</span><br></pre></td></tr></table></figure>

<h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>首先启动一个node的容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it -p 4000:4000 node &#x2F;bin&#x2F;bash</span><br><span class="line"># 映射容器的4000端口到host的4000端口，是为了方便测试hexo生成的静态网站是否正常</span><br></pre></td></tr></table></figure>

<p>然后，安装hexo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h3 id="创建git仓库"><a href="#创建git仓库" class="headerlink" title="创建git仓库"></a>创建git仓库</h3><p>gitpage对仓库的要求就是仓库名的格式必须为：username.github.io，例如本文仓库名：duguhaotian.github.io</p>
<h3 id="配置git公钥"><a href="#配置git公钥" class="headerlink" title="配置git公钥"></a>配置git公钥</h3><p>首先，在容器中生成公钥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>
<p>然后拷贝公钥到你Git上，具体步骤百度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure>

<h3 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h3><p>配置用户名和邮箱</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name   xxxx</span><br><span class="line">git config --global user.email  xxxx@xxx.com</span><br></pre></td></tr></table></figure>

<h2 id="构建hexo工程"><a href="#构建hexo工程" class="headerlink" title="构建hexo工程"></a>构建hexo工程</h2><p>创建工程目录，然后通过hexo初始化目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir test</span><br><span class="line">hexo init test</span><br></pre></td></tr></table></figure>

<p>生成的目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~&#x2F;test# tree -L 1</span><br><span class="line">.</span><br><span class="line">|-- _config.yml</span><br><span class="line">|-- db.json</span><br><span class="line">|-- node_modules</span><br><span class="line">|-- package-lock.json</span><br><span class="line">|-- package.json</span><br><span class="line">|-- public</span><br><span class="line">|-- scaffolds</span><br><span class="line">|-- source</span><br><span class="line">|-- themes</span><br></pre></td></tr></table></figure>

<p>增加博客的方式有两种：</p>
<ul>
<li>通过hexo生成新的博客文件，然后写博客</li>
<li>或者把写好的博客文件（markdown格式），放入test/source/_posts/目录</li>
</ul>
<h2 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h2><p>由于hexo依赖一些库，如支持推送静态页面到git的库等。最好安装下面所有库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>

<h2 id="生成静态网站"><a href="#生成静态网站" class="headerlink" title="生成静态网站"></a>生成静态网站</h2><p>在test目录执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 生成静态页面</span><br><span class="line">hexo g </span><br><span class="line"># 可以选择在generate的时候，watch源文件的变化，hexo感知到源文件变化，会自动重新出发generate，从而达到动态更新博客的效果</span><br><span class="line">hexo g -w</span><br><span class="line"></span><br><span class="line"># 部署本地静态网站(localhost:4000)</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p><strong><em>注意：这里的watch会为我们后续自动更新博客做到很好的支持</em></strong></p>
<p>查看本地静态网站是否构建正常，如果无问题，直接推送到github仓库。</p>
<h2 id="推送到GitPage"><a href="#推送到GitPage" class="headerlink" title="推送到GitPage"></a>推送到GitPage</h2><p>当本地网站验证无误，就可以推送到你的Git仓库了，然后Github会自动部署你的GitPage。</p>
<p>首先，安装依赖的插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>然后，修改hexo的配置文件：_config.yml ，增加deploy的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;duguhaotian&#x2F;duguhaotian.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>配置文件默认情况如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type:</span><br></pre></td></tr></table></figure>
<p>因此，我们增加type和对应的repository地址，还有git分支。</p>
<p>最后，直接利用hexo的deploy功能把hexo生成的静态页面推送到Github上我们新建的仓库。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br><span class="line"># 或者</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>

<h2 id="跟换主题"><a href="#跟换主题" class="headerlink" title="跟换主题"></a>跟换主题</h2><p>首先，在hexo官网找到自己需要的皮肤：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a><br>例如，material的皮肤，然后获取git地址：<a href="https://github.com/viosey/hexo-theme-material" target="_blank" rel="noopener">https://github.com/viosey/hexo-theme-material</a></p>
<p>主要步骤：</p>
<ul>
<li>把该目录拷贝到themes/下面</li>
<li>重命名为material</li>
<li>修改test/_config.yml配置文件中theme为：material</li>
<li>把test/theme/material/_config.template.yml拷贝一份为:test/themes/material/_config.yaml，不然hexo生成静态页面会错误</li>
</ul>
<h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><p>主题可以在github上面，搜索hexo-theme，然后找到适合自己的主题。本文已<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">hexo-theme-next</a>为例。</p>
<h3 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h3><p>hexo工作目录为hexospace。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd hexospace</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>

<p>修改hexospace/_config.yml的theme项为<code>theme: next</code>。</p>
<h3 id="添加tags和categories页面"><a href="#添加tags和categories页面" class="headerlink" title="添加tags和categories页面"></a>添加tags和categories页面</h3><p>分别生成对应的index.md</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>

<p>修改生成的index.md为如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat source&#x2F;tags&#x2F;index.md </span><br><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2019-09-01 14:41:38</span><br><span class="line">type: &quot;tags&quot;   &#x2F;&#x2F;手动增加</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat source&#x2F;categories&#x2F;index.md </span><br><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2019-09-01 14:42:03</span><br><span class="line">type: &quot;categories&quot;   &#x2F;&#x2F;手动增加</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h3 id="配置gitalk"><a href="#配置gitalk" class="headerlink" title="配置gitalk"></a>配置gitalk</h3><p>首先，生成授权需要的id和secret，网址：<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">https://github.com/settings/applications/new</a></p>
<p>具体配置参考下图：</p>
<p><img src="/images/gitalk_oauth.png" alt="gitalk oauth"></p>
<p>然后配置next/_config.yml：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitalk:</span><br><span class="line">  enable: true</span><br><span class="line">  github_id: 你的github账号 # GitHub repo owner</span><br><span class="line">  repo: 只需要repo名字就行了，例如test # Repository name to store issues</span><br><span class="line">  client_id: 上面生成的id # GitHub Application Client ID</span><br><span class="line">  client_secret: 上面生成的秘钥 # GitHub Application Client Secret</span><br><span class="line">  admin_user: 你的github账号 # GitHub repo owner and collaborators, only these guys can initialize gitHub issues</span><br></pre></td></tr></table></figure>

<p>更多配置可以参考下面的手册：<a href="https://theme-next.org/docs/getting-started/" target="_blank" rel="noopener">https://theme-next.org/docs/getting-started/</a></p>
<h3 id="支持mermaid"><a href="#支持mermaid" class="headerlink" title="支持mermaid"></a>支持mermaid</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -s hexo-filter-mermaid-diagrams</span><br></pre></td></tr></table></figure>

<p>next主题支持mermaid，需要开启，开启方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Mermaid tag</span><br><span class="line">mermaid:</span><br><span class="line">  enable: true</span><br><span class="line">  # Available themes: default | dark | forest | neutral</span><br><span class="line">  theme: default</span><br><span class="line">  cdn: &#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;mermaid@8&#x2F;dist&#x2F;mermaid.min.js</span><br></pre></td></tr></table></figure>

<h2 id="自动更新博客"><a href="#自动更新博客" class="headerlink" title="自动更新博客"></a>自动更新博客</h2><p>当我们的博客源文件存储在github上面的时候，那么在修改、删除和新增博客时，每次都需要把博客拷贝到我们的hexo的工作目录，加上上面的watch功能，可以自动生成新的博客，并且更新hexo服务器中的博客。</p>
<p>那么，如果我们借助github的webhook功能，动态感知博客源文件仓库的变化，然后自动更新博客源文件，然后出发hexo的自动更新功能。答案是可以的。下面是一个简单的尝试 ，后续有时间会继续优化。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bytes"</span></span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"flag"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"os/exec"</span></span><br><span class="line">	<span class="string">"path"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	notesPath <span class="keyword">string</span></span><br><span class="line">	hexoPath  <span class="keyword">string</span></span><br><span class="line">	lock      sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.StringVar(&amp;notesPath, <span class="string">"notes"</span>, <span class="string">"./notes"</span>, <span class="string">"path where store notes"</span>)</span><br><span class="line">	flag.StringVar(&amp;hexoPath, <span class="string">"hexo"</span>, <span class="string">"./test/source/_posts/"</span>, <span class="string">"path where store hexo source post"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name     <span class="keyword">string</span> <span class="string">`json:"name,omitempty"`</span></span><br><span class="line">	Email    <span class="keyword">string</span> <span class="string">`json:"email,omitempty"`</span></span><br><span class="line">	Username <span class="keyword">string</span> <span class="string">`json:"username,omitempty"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// github webhook commit format</span></span><br><span class="line"><span class="keyword">type</span> Commit <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID        <span class="keyword">string</span>   <span class="string">`json:"id"`</span></span><br><span class="line">	Tree_id   <span class="keyword">string</span>   <span class="string">`json:"tree_id"`</span></span><br><span class="line">	Distinct  <span class="keyword">bool</span>     <span class="string">`json:"distinct"`</span></span><br><span class="line">	Message   <span class="keyword">string</span>   <span class="string">`json:"message,omitempty"`</span></span><br><span class="line">	Timestamp <span class="keyword">string</span>   <span class="string">`json:"timestamp,omitempty"`</span></span><br><span class="line">	Url       <span class="keyword">string</span>   <span class="string">`json:"url,omitempty"`</span></span><br><span class="line">	Author    *User    <span class="string">`json:"author,omitempty"`</span></span><br><span class="line">	Committer *User    <span class="string">`json:"committer,omitempty"`</span></span><br><span class="line">	Added     []<span class="keyword">string</span> <span class="string">`json:"added,omitempty"`</span></span><br><span class="line">	Removed   []<span class="keyword">string</span> <span class="string">`json:"removed,omitempty"`</span></span><br><span class="line">	Modified  []<span class="keyword">string</span> <span class="string">`json:"modified,omitempty"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runCmd</span><span class="params">(cmdStr <span class="keyword">string</span>, args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	cmd := exec.Command(cmdStr, args...)</span><br><span class="line">	<span class="keyword">var</span> out bytes.Buffer</span><br><span class="line">	cmd.Stdout = &amp;out</span><br><span class="line">	err := cmd.Run()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">"run %s failed: %s"</span>, cmdStr, err.Error())</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateHandle</span><span class="params">(files []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> files &#123;</span><br><span class="line">		_, fname := path.Split(f)</span><br><span class="line">		runCmd(<span class="string">"cp"</span>, []<span class="keyword">string</span>&#123;<span class="string">"-f"</span>, notesPath + <span class="string">"/"</span> + f, hexoPath + <span class="string">"/"</span> + fname&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeHandle</span><span class="params">(files []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> files &#123;</span><br><span class="line">		_, fname := path.Split(f)</span><br><span class="line">		runCmd(<span class="string">"rm"</span>, []<span class="keyword">string</span>&#123;<span class="string">"-f"</span>, hexoPath + <span class="string">"/"</span> + fname&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">syncGit</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	err := runCmd(<span class="string">"/bin/bash"</span>, []<span class="keyword">string</span>&#123;<span class="string">"-c"</span>, <span class="string">"cd "</span> + notesPath + <span class="string">"; git pull"</span>&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">"sync notes from git failed: %s\n"</span>, err.Error())</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changes</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">string</span>, []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> copys []<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">var</span> rms []<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">var</span> commit Commit</span><br><span class="line"></span><br><span class="line">	err := json.Unmarshal(data, &amp;commit)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">"Invalid commit: %s"</span>, <span class="keyword">string</span>(data))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(commit.Added) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		copys = commit.Added</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(commit.Modified) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		copys = <span class="built_in">append</span>(copys, commit.Modified...)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(commit.Removed) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		rms = commit.Removed</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log.Printf(<span class="string">"copys: %v, removes: %v\n"</span>, copys, rms)</span><br><span class="line">	<span class="keyword">return</span> copys, rms</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleCommits</span><span class="params">(commits []<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> updates []<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">var</span> removes []<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">for</span> _, commit := <span class="keyword">range</span> commits &#123;</span><br><span class="line">		data, err := json.Marshal(commit)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">"Invalid commit: %v"</span>, commit)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		us, rs := changes(data)</span><br><span class="line">		updates = <span class="built_in">append</span>(updates, us...)</span><br><span class="line">		removes = <span class="built_in">append</span>(removes, rs...)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> lock.Unlock()</span><br><span class="line">	<span class="keyword">if</span> !syncGit() &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	updateHandle(updates)</span><br><span class="line">	removeHandle(removes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.Parse()</span><br><span class="line">	log.Printf(<span class="string">"notes path: %s\n"</span>, notesPath)</span><br><span class="line">	log.Printf(<span class="string">"hexo path: %s\n"</span>, hexoPath)</span><br><span class="line"></span><br><span class="line">	helloHandler := <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> fullData <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">		robots, err := ioutil.ReadAll(req.Body)</span><br><span class="line">		req.Body.Close()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err := json.Unmarshal([]<span class="keyword">byte</span>(robots), &amp;fullData); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line">		commits, ok := fullData[<span class="string">"commits"</span>]</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			log.Printf(<span class="string">"Cannot found commits in %s"</span>, fullData)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> t, ok := commits.([]<span class="keyword">interface</span>&#123;&#125;); ok &#123;</span><br><span class="line">			handleCommits(t)</span><br><span class="line">		&#125;</span><br><span class="line">		log.Println(<span class="string">"get message"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	http.HandleFunc(<span class="string">"/notes"</span>, helloHandler)</span><br><span class="line">	log.Fatal(http.ListenAndServe(<span class="string">":8088"</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="博客系统的完整结构"><a href="#博客系统的完整结构" class="headerlink" title="博客系统的完整结构"></a>博客系统的完整结构</h2><pre class="mermaid">sequenceDiagram
    participant A as User
    participant B as GithubRepo
    participant C as Listener
    participant D as HexoServer
    activate C
    activate D
    A ->> B: 更新、增加或者删除博客
    B ->> C: webhook push event
    loop new commit
        C ->> C: 1. 更新博客repo；2. 更新hexo博客源文件
    end
    deactivate C
    loop hexo服务
        D ->> D: 1. 监听博客源文件变化；2.自动生成新的静态页面；3. 更新服务器内容
    end
    deactivate D</pre>

<p>我们需要两个服务器：</p>
<ul>
<li>一个是接收github的webhook推送信息，并且根据推送的信息，更新hexo的博客源文件</li>
<li>一个是hexo的服务器，用于提供hexo博客服务</li>
</ul>
<p>一个流程基本如上图所示：</p>
<ol>
<li>用户更新博客，并且推送到github的博客仓库；</li>
<li>github根据配置的webhook，发送commit信息到listener服务器；</li>
<li>listener服务器根据，commit信息，更新当前hexo管理的博客源文件；</li>
<li>hexo在generate的时候，配置了watch，因此在感知到源文件变化时，会重新生成静态页面。</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://hexo.io/docs/" target="_blank" rel="noopener">https://hexo.io/docs/</a></li>
<li><a href="https://theme-next.org/docs/getting-started/" target="_blank" rel="noopener">https://theme-next.org/docs/getting-started/</a></li>
<li><a href="https://www.jianshu.com/p/15ae47eddc56" target="_blank" rel="noopener">https://www.jianshu.com/p/15ae47eddc56</a></li>
<li><a href="https://www.docker-cn.com/registry-mirror" target="_blank" rel="noopener">https://www.docker-cn.com/registry-mirror</a></li>
<li><a href="https://docs.docker.com/" target="_blank" rel="noopener">https://docs.docker.com/</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
        <category>hexo</category>
        <category>gitpage</category>
      </categories>
  </entry>
  <entry>
    <title>perl的locale异常</title>
    <url>/2018/01/21/perl_locale_error/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">perl: warning: Falling back to the standard locale (<span class="string">"C"</span>).</span><br><span class="line">perl: warning: Setting locale failed.</span><br><span class="line">sh: warning: setlocale: LC_ALL: cannot change locale (en_US.UTF-8)</span><br><span class="line">sh: warning: setlocale: LC_ALL: cannot change locale (en_US.UTF-8)</span><br></pre></td></tr></table></figure>

<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">locale-gen en_US en_US.UTF-8</span><br><span class="line">dpkg-reconfigure locales</span><br><span class="line">locale</span><br><span class="line">export LC_ALL&#x3D;en_US.UTF-8</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
        <category>perl</category>
      </categories>
  </entry>
  <entry>
    <title>电子书制作记录</title>
    <url>/2018/01/21/get_ebook_spard/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<p>博客：<a href="http://abirdcfly.github.io/2016/03/07/calibre2mobi/" target="_blank" rel="noopener">http://abirdcfly.github.io/2016/03/07/calibre2mobi/</a></p>
]]></content>
      <categories>
        <category>电子书</category>
      </categories>
  </entry>
  <entry>
    <title>IP命令使用</title>
    <url>/2018/01/08/ip_command/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<h2 id="up-down-veth接口"><a href="#up-down-veth接口" class="headerlink" title="up/down veth接口"></a>up/down veth接口</h2><p>Usage:</p>
<pre><code>ip link set dev &lt;interface&gt; up
ip link set dev &lt;interface&gt; down</code></pre><p>Example:</p>
<pre><code>ip link set dev eth0 up
ip link set dev eth0 down</code></pre><h2 id="创建veth对"><a href="#创建veth对" class="headerlink" title="创建veth对"></a>创建veth对</h2><p>Usage:</p>
<pre><code>ip link add &lt;interface nameA&gt; type veth peer name &lt;interface nameB&gt;</code></pre><p>Example:</p>
<pre><code>ip link add veth0 type veth peer name veth1</code></pre><h2 id="设置veth网络命名空间"><a href="#设置veth网络命名空间" class="headerlink" title="设置veth网络命名空间"></a>设置veth网络命名空间</h2><p>Usage:</p>
<pre><code>ip link set &lt;interface&gt; netns &lt;netnamespace&gt;</code></pre><p>Example:</p>
<pre><code>ip netns add hello_test  //创建一个名为hell_test的netns（网络命名空间）
ip link set veth1 netns hello_test</code></pre><h2 id="重命名veth接口"><a href="#重命名veth接口" class="headerlink" title="重命名veth接口"></a>重命名veth接口</h2><p>Usage:</p>
<pre><code>ip link set vethA name vethB</code></pre><p>Example:</p>
<pre><code>ip link set vethA down
ip link set vethA name vethB
ip link set vethB up</code></pre>]]></content>
      <categories>
        <category>linux</category>
        <category>tools</category>
        <category>ip</category>
      </categories>
  </entry>
  <entry>
    <title>Git用法</title>
    <url>/2018/01/07/git_usages/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<h1 id="Git用法汇总"><a href="#Git用法汇总" class="headerlink" title="Git用法汇总"></a>Git用法汇总</h1><h2 id="Git命令自动补全"><a href="#Git命令自动补全" class="headerlink" title="Git命令自动补全"></a>Git命令自动补全</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/bash_completion.d/git</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"><span class="built_in">source</span> /usr/share/bash-completion/completions/git</span><br></pre></td></tr></table></figure>

<p>可以添加到~/.bashrc</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>tools</category>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>技术汇集</title>
    <url>/2018/01/01/knowledge_topology/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<h2 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h2><p>c语言测试套框架：<a href="https://libcheck.github.io/check/" target="_blank" rel="noopener">https://libcheck.github.io/check/</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>pip命令初识</title>
    <url>/2017/12/12/pip_command/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><h3 id="1-安装指定版本的包"><a href="#1-安装指定版本的包" class="headerlink" title="1. 安装指定版本的包"></a>1. 安装指定版本的包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install docker-py&#x3D;&#x3D;1.8.1</span><br></pre></td></tr></table></figure>

<h3 id="2-使用代理proxy"><a href="#2-使用代理proxy" class="headerlink" title="2. 使用代理proxy"></a>2. 使用代理proxy</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 --proxy&#x3D;http:&#x2F;&#x2F;username:password@proxy.com:8080 install docker-py&#x3D;&#x3D;1.8.1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
        <category>python</category>
        <category>pip</category>
      </categories>
  </entry>
  <entry>
    <title>nginx问题跟踪</title>
    <url>/2017/08/08/nginx_related/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>访问nginx搭建的网站时，报403 forbidden错误的原因。</p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>第一，是因为缺少index.html或者index.php等<br>第二，是因为没有权限。</p>
<p>参考：<br><a href="http://blog.51yip.com/apachenginx/1512.html" target="_blank" rel="noopener">http://blog.51yip.com/apachenginx/1512.html</a></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>tools</category>
        <category>nginx</category>
      </categories>
  </entry>
  <entry>
    <title>legacy_va_layout设置大堆</title>
    <url>/2017/06/02/linux_kernel_bigheap/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<p>设置/proc/sys/vm/legacy_va_layout为0，调整进程地址空间的heap增长方向为从上往下。<br>这样可以使得heap的上限超过2G。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 ----------------------------------------------------------------------------------------- 3G -------- 4G</span><br><span class="line">保留 | 代码段 | 数据段 | BSS段 | 堆-增长方向向上 | 内存映射 | 栈-增长方向向下 | 命令行参数 | 环境变量    内核段</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;legacy_va_layout (since Linux 2.6.9)</span><br><span class="line">              If nonzero, this disables the new 32-bit memory-mapping</span><br><span class="line">              layout; the kernel will use the legacy (2.4) layout for all</span><br><span class="line">              processes.</span><br></pre></td></tr></table></figure>

<p>修改heap增长方向代码（以linux4.1的arm为例）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void arch_pick_mmap_layout(struct mm_struct *mm)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long random_factor &#x3D; 0UL;</span><br><span class="line"></span><br><span class="line">	if (current-&gt;flags &amp; PF_RANDOMIZE)</span><br><span class="line">		random_factor &#x3D; arch_mmap_rnd();</span><br><span class="line"></span><br><span class="line">	if (mmap_is_legacy()) &#123;  &#x2F;&#x2F;获取legacy_va_layout的值，非零使用正常模式</span><br><span class="line">		mm-&gt;mmap_base &#x3D; TASK_UNMAPPED_BASE + random_factor;</span><br><span class="line">		mm-&gt;get_unmapped_area &#x3D; arch_get_unmapped_area;</span><br><span class="line">	&#125; else &#123;  &#x2F;&#x2F;为零，使用自上向下的模式</span><br><span class="line">		mm-&gt;mmap_base &#x3D; mmap_base(random_factor);</span><br><span class="line">		mm-&gt;get_unmapped_area &#x3D; arch_get_unmapped_area_topdown;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
        <category>bigheap</category>
        <category>legacy_va_layout</category>
      </categories>
  </entry>
  <entry>
    <title>watchdog分析</title>
    <url>/2017/06/02/linux_scheduling_softlockup&amp;hardlockup/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<h2 id="softlockup和hardlockup含义"><a href="#softlockup和hardlockup含义" class="headerlink" title="softlockup和hardlockup含义"></a>softlockup和hardlockup含义</h2><h3 id="softlockup"><a href="#softlockup" class="headerlink" title="softlockup"></a>softlockup</h3><p>内核在内核模式loop超过get_softlockup_thresh()获取的阈值时间，导致其他任务没有机会运行的bug，称为”softlockup”。<br>简单来说，就是抢占被关闭时间超过阈值，导致其他进程无法调度。</p>
<h3 id="hardlockup"><a href="#hardlockup" class="headerlink" title="hardlockup"></a>hardlockup</h3><p>CPU在内核模式loop时间超过hw_nmi_get_sample_period函数获取的阈值时间，导致其他中断不能运行的bug，称为”hardlockup”。<br>简单来说，就是中断被关闭时间超过阈值，导致其他中断无法运行。</p>
<h2 id="softlockup注册和触发流程"><a href="#softlockup注册和触发流程" class="headerlink" title="softlockup注册和触发流程"></a>softlockup注册和触发流程</h2><h3 id="基于proc文件系统的watchdog流程"><a href="#基于proc文件系统的watchdog流程" class="headerlink" title="基于proc文件系统的watchdog流程"></a>基于proc文件系统的watchdog流程</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">proc_watchdog_update 更新watchdog状态，如果开启了watchdog，触发开狗流程</span><br><span class="line">  --&gt; watchdog_enable_all_cpus 打开所有cpu的狗</span><br><span class="line">    --&gt; smpboot_register_percpu_thread(&amp;watchdog_threads) 创建启动所有CPU上面的hotplug相关线程</span><br><span class="line">        --&gt; __smpboot_create_thread 创建线程，线程执行的函数是smpboot_thread_fn</span><br><span class="line">          --&gt; smpboot_thread_fn 开始会注册调用watchdog_threads的<span class="built_in">setup</span>（就是watchdog_enable），正常流程会不断的执行watchdog_threads的thread_fn</span><br><span class="line">            --&gt; watchdog_enabled 会启动一个hrtimer的定时器，触发的回调函数是watchdog_timer_fn</span><br><span class="line">              --&gt; watchdog_timer_fn 根据is_softlockup判断是否发生softlockup</span><br></pre></td></tr></table></figure>

<p>watchdog函数就是喂狗，保证不出现softlockup，这里不需要关注太详细。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void watchdog(unsigned int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	__this_cpu_write(soft_lockup_hrtimer_cnt,</span><br><span class="line">			 __this_cpu_read(hrtimer_interrupts));</span><br><span class="line">	__touch_watchdog();</span><br><span class="line"></span><br><span class="line">	if (!(watchdog_enabled &amp; NMI_WATCHDOG_ENABLED))</span><br><span class="line">		watchdog_nmi_disable(cpu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内核初始化时的流程"><a href="#内核初始化时的流程" class="headerlink" title="内核初始化时的流程"></a>内核初始化时的流程</h3><p>tick的方式，注册watchdog。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kernel_init 内核初始化</span><br><span class="line">  --&gt; kernel_init_freeable </span><br><span class="line">    --&gt; lockup_detector_init 如果开狗了会执行watchdog_enable_all_cpus；如果开启了CONFIG_TICKLESS，会注册tick_notify。</span><br><span class="line">      --&gt; watchdog_enable_all_cpus 后续流程和proc的一致，参考上面的分析</span><br><span class="line">      --&gt; register_tick_notifier 注册回调函数softlockup_tickonoff_callback</span><br><span class="line">        --&gt; softlockup_tickonoff_callback 注册回调函数softlockup_tick_onoff</span><br><span class="line">          --&gt; softlockup_tick_onoff 如果tick是打开的，会启动一个hrtimer，定期执行watchdog_timer_fn函数</span><br><span class="line">            --&gt; watchdog_timer_fn 和上面的流程一致了</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
        <category>scheduling</category>
        <category>watchdog</category>
        <category>softlockup</category>
        <category>hardlockup</category>
      </categories>
  </entry>
  <entry>
    <title>ip操作docker容器命名空间</title>
    <url>/2017/05/08/ip_manipulate_docker_netns/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>在host上，操作容器的网络设备</p>
<ul>
<li><p>需要查到容器的进程id==cpid，可以通过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cpid&#x3D;$(docker inspect --format &#39;&#123;&#123;.State.Pid&#125;&#125;&#39; $1)</span><br></pre></td></tr></table></figure>
</li>
<li><p>需要把容器的netns挂到ip命令能操作的netns中—–</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s &quot;&#x2F;proc&#x2F;$cpid&#x2F;ns&#x2F;net&quot; &quot;&#x2F;var&#x2F;run&#x2F;netns&#x2F;$cpid&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看容器中所有的网络设备以及配置信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip netns exec $cpid ip a</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看容器中网络设备的类型信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip netns exec $cpid ethtool &quot;driver name（如eth0）&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
        <category>docker</category>
        <category>ip</category>
      </categories>
  </entry>
  <entry>
    <title>sqlite数据库修改失败</title>
    <url>/2017/05/07/sqlite_can_not_write_error/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>用sqlite data browser 执行update命令，报错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unable to open database file</span><br></pre></td></tr></table></figure>

<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>sqlite库在对数据库进行操作时（本人估计是写操作），会在数据库的当前文件夹下创建一个临时文件，当操作结束时，该临时文件将被删除。 而远程用户一般不具备有对临时文件足够的权限,<br>所以会造成 无法打开、写或者删除临时文件。解决的方法就是递归地（加-R）将数据库所在文件夹设置为任何用户都有可读可写可删的权限。假如sqlite数据库路径为/database/， 则：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod -R 755 /database/</span><br></pre></td></tr></table></figure>

<p>参考文章：<a href="http://blog.csdn.net/benthy2/article/details/17901821" target="_blank" rel="noopener">http://blog.csdn.net/benthy2/article/details/17901821</a></p>
]]></content>
      <categories>
        <category>sqlite</category>
      </categories>
  </entry>
  <entry>
    <title>基于docker容器的wordpress迁移</title>
    <url>/2017/05/07/docker_wordpress_migrate/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>我的wordpress是用sqlite作为数据库的<br>wordpress是运行在docker容器里面的<br>网站的所有数据都有备份<br>安装docker<br>按照“基于centos搭建wordpress的docker镜像”制作对应的docker镜像（假设名字为wordpress_sqlite）<br>拷贝备份数据到新机器的/workspace/wordpress/blogs/，执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run –privileged -itd -p 8080:80 -v /workspace/wordpress/blogs/:/var/www/html wordpress_sqlite bash -l -c “/sbin/init”</span><br></pre></td></tr></table></figure>

<p>此时，网站应该可以正常运行了。</p>
<p>注意：如果你修改了网站的域名，那么需要对sqlite数据库的数据进行修改。</p>
<p>##问题</p>
<p>当迁移的机器域名变化时，需要怎么修改网站配置。</p>
<p>准备环境：安装sqlite3，sqlitebrowser</p>
<p>最重要的就是需要修改两个配置：</p>
<p>WordPress地址（URL）—-对应wp_options的 home<br>站点地址（URL）—-对应wp_options的 siteurl</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE wp_options SET option_value &#x3D; replace( option_value, ‘http:&#x2F;&#x2F;www.old.com’, ‘http:&#x2F;&#x2F;www.new.com’ ) WHERE option_name &#x3D; ‘home’ OR option_name &#x3D; ‘siteurl’;</span><br><span class="line">UPDATE wp_posts SET post_content &#x3D; replace( post_content, ‘http:&#x2F;&#x2F;www.old.com’, ‘http:&#x2F;&#x2F;www.new.com’ ) ;</span><br><span class="line">UPDATE wp_posts SET guid &#x3D; replace( guid, ‘http:&#x2F;&#x2F;www.old.com’, ‘http:&#x2F;&#x2F;www.new.com’ ) ;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>第一，参考文章“sqlite数据库不能修改”</li>
<li>第二，参考文章“wordpress登陆跳转卡住”</li>
<li>第三，sqlitebrowser在update之后，需要执行“write changes”按钮，才能把修改写入到数据库文件中。</li>
</ul>
<p>参考文章：</p>
<ul>
<li><a href="http://www.2zzt.com/jcandcj/5883.html" target="_blank" rel="noopener">http://www.2zzt.com/jcandcj/5883.html</a></li>
<li><a href="http://jingyan.baidu.com/article/ff4116258f144012e48237a7.html" target="_blank" rel="noopener">http://jingyan.baidu.com/article/ff4116258f144012e48237a7.html</a></li>
</ul>
]]></content>
      <categories>
        <category>wordpress</category>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title>wordpress登陆跳转卡住</title>
    <url>/2017/05/07/wordpress_login_fail/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>以<a href="http://www.example.com域名为例" target="_blank" rel="noopener">www.example.com域名为例</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">www.example.com&#x2F;wp-login.php?redirect_to&#x3D;www.example.com&#x2F;wp-admin%2F&amp;reauth&#x3D;1</span><br></pre></td></tr></table></figure>

<p>用户名和密码都是正确的，在redirect的时候，卡住不动。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>这是由于wp-admin文件夹的权限问题导致的，可以修改该文件夹的访问权限，“chmod -R 755 wp-admin”</p>
<p>参考文章：<a href="http://wordpress.stackexchange.com/questions/113161/wp-admin-url-doesnt-allow-to-login-and-redirects-to-same-page" target="_blank" rel="noopener">http://wordpress.stackexchange.com/questions/113161/wp-admin-url-doesnt-allow-to-login-and-redirects-to-same-page</a></p>
]]></content>
      <categories>
        <category>wordpress</category>
      </categories>
  </entry>
  <entry>
    <title>Git代理配置及常见错误解决办法</title>
    <url>/2017/05/07/git_use_error_fix/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<h2 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config –global http.proxy http://name:password@proxyhk.huawei.com:8080</span><br><span class="line"></span><br><span class="line">git config –global https.proxy http://name:password@proxyhk.huawei.com:8080</span><br></pre></td></tr></table></figure>

<p>比如这种错误的时候fatal: unable to access ‘<a href="https://github.com/kubernetes/kubernetes.git/’" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes.git/’</a>: server certificate verification failed. CAfile: /etc/ssl/certs/ca-certificates.crt CRLfile: none</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config –global http.sslverify <span class="literal">false</span> （解决证书验证问题）</span><br><span class="line"></span><br><span class="line">git config –global https.sslverify <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>注：不过这样并没有解决你证书的问题，只是跳过了而已。</p>
<h2 id="Ubuntu在clone大的项目异常"><a href="#Ubuntu在clone大的项目异常" class="headerlink" title="Ubuntu在clone大的项目异常"></a>Ubuntu在clone大的项目异常</h2><p>可能会出下面的错误:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: gnutls_handshake() failed: A TLS packet with unexpected length was received. while accessing …</span><br><span class="line">fatal: HTTP request failed</span><br></pre></td></tr></table></figure>

<p>这就需要你自己重新编译安装git了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential fakeroot dpkg-dev libcurl4-openssl-dev</span><br><span class="line">sudo apt-get build-dep git</span><br><span class="line">mkdir ~/git-openssl</span><br><span class="line"><span class="built_in">cd</span> ~/git-openssl</span><br><span class="line">apt-get <span class="built_in">source</span> git</span><br><span class="line">dpkg-source -x git_1.7.9.5-1.dsc</span><br><span class="line"><span class="built_in">cd</span> git-1.7.9.5</span><br></pre></td></tr></table></figure>

<p>修改“debian/control”文件，把所有的“libcurl4-gnutls-dev” 替换成“libcurl4-openssl-dev”</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dpkg-buildpackage -rfakeroot -b</span><br></pre></td></tr></table></figure>

<p>安装对应的版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i386: sudo dpkg -i ..&#x2F;git_1.7.9.5-1_i386.deb</span><br><span class="line"></span><br><span class="line">x86_64: sudo dpkg -i ..&#x2F;git_1.7.9.5-1_amd64.deb</span><br></pre></td></tr></table></figure>

<p>注：git版本号，注意修改为你下载的对应版本号</p>
<p>参考文章：</p>
<p><a href="http://askubuntu.com/questions/186847/error-gnutls-handshake-failed-when-connecting-to-https-servers/187199#187199" target="_blank" rel="noopener">http://askubuntu.com/questions/186847/error-gnutls-handshake-failed-when-connecting-to-https-servers/187199#187199</a></p>
]]></content>
      <categories>
        <category>Git</category>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>golang strings.Join一个字符串的情况</title>
    <url>/2017/05/07/golang_string_join_usage/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rt :&#x3D; strings.Join([]string&#123;“help”&#125;, “-“)</span><br><span class="line">fmt.Println(rt)</span><br><span class="line">return</span><br></pre></td></tr></table></figure>

<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>此时help后面不会加上“-”，只会打印一个“help”</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title>Docker代理配置</title>
    <url>/2017/05/07/docker_set_proxy/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<h2 id="非systemd情况下"><a href="#非systemd情况下" class="headerlink" title="非systemd情况下"></a>非systemd情况下</h2><p>直接修改/etc/default/docker文件就行（Ubuntu下service启动docker，属于非systemd模式）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=xxxxxx</span><br><span class="line"><span class="built_in">export</span> https_proxy=xxxxxx</span><br></pre></td></tr></table></figure>

<h2 id="systemd模式下"><a href="#systemd模式下" class="headerlink" title="systemd模式下"></a>systemd模式下</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /etc/systemd/system/docker.service.d</span><br><span class="line">touch /etc/systemd/system/docker.service.d/http-proxy.conf</span><br></pre></td></tr></table></figure>

<p>添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Service] Environment=”HTTP_PROXY=http://proxy.example.com:80/”</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Environment=”HTTP_PROXY=http://proxy.example.com:80/” “NO_PROXY=localhost,127.0.0.1,docker-registry.somecorporation.com”</span><br></pre></td></tr></table></figure>

<p>刷新配置：sudo systemctl daemon-reload</p>
<p>验证配置是否成功：systemctl show –property=Environment docker</p>
<p>重启docker服务：sudo systemctl restart docker</p>
<p>参考文章</p>
<p><a href="https://docs.docker.com/engine/admin/systemd/" target="_blank" rel="noopener">https://docs.docker.com/engine/admin/systemd/</a></p>
<p><a href="http://www.jianshu.com/p/2e0c9ed5433d" target="_blank" rel="noopener">http://www.jianshu.com/p/2e0c9ed5433d</a></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title>获取qemu创建的虚拟机的IP地址</title>
    <url>/2017/05/07/qemu_get_vm_ip/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<h2 id="先用virsh-net-list获取虚拟机的网络列表"><a href="#先用virsh-net-list获取虚拟机的网络列表" class="headerlink" title="先用virsh net-list获取虚拟机的网络列表"></a>先用virsh net-list获取虚拟机的网络列表</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost vms]<span class="comment"># virsh net-list</span></span><br><span class="line">Name State Autostart Persistent</span><br><span class="line">———————————————————-</span><br><span class="line">default active yes yes</span><br></pre></td></tr></table></figure>

<h2 id="然后获取IP的分配列表"><a href="#然后获取IP的分配列表" class="headerlink" title="然后获取IP的分配列表"></a>然后获取IP的分配列表</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost vms]<span class="comment"># virsh net-dhcp-leases default</span></span><br><span class="line">Expiry Time MAC address Protocol IP address Hostname Client ID or DUID</span><br><span class="line">——————————————————————————————————————-</span><br><span class="line">2016-09-22 21:08:03 52:54:00:00:00:12 ipv4 192.168.122.7/24 rtos –</span><br><span class="line">2016-09-22 21:08:23 52:54:00:00:00:42 ipv4 192.168.122.226/24 rtos –</span><br><span class="line">2016-09-22 21:08:35 52:54:00:00:00:62 ipv4 192.168.122.5/24 rtos –</span><br></pre></td></tr></table></figure>

<h2 id="获取虚拟机的列表"><a href="#获取虚拟机的列表" class="headerlink" title="获取虚拟机的列表"></a>获取虚拟机的列表</h2><p>[root@localhost vms]# virsh list<br>Id Name State<br>—————————————————-<br>12 main running<br>13 slaver1 running<br>14 slaver2 running</p>
<p>注：virsh net-dhcp-leases 网络名：会把该网络上分配出去的IP地址显示出来</p>
<h2 id="获取制定虚拟机的IP"><a href="#获取制定虚拟机的IP" class="headerlink" title="获取制定虚拟机的IP"></a>获取制定虚拟机的IP</h2><p>virsh edit vmID可以看到虚拟机的MAC地址，然后到第二步中找到对应的IP。</p>
<p>如果有更好的办法可以联系我：<a href="mailto:duguhaotian@gmail.com">duguhaotian@gmail.com</a></p>
]]></content>
      <categories>
        <category>qemu</category>
        <category>虚拟机</category>
      </categories>
  </entry>
  <entry>
    <title>Centos7 qemu虚拟机安装</title>
    <url>/2017/05/07/install_vm_on_centos7/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<h2 id="需要的材料"><a href="#需要的材料" class="headerlink" title="需要的材料"></a>需要的材料</h2><h3 id="qemu-kvm"><a href="#qemu-kvm" class="headerlink" title="qemu-kvm"></a>qemu-kvm</h3><p>能运行的qemu虚拟机镜像文件（如果你的机器是远端服务器，没办法使用virt-view等图形界面的话）<br>已有的qemu系统镜像安装了openssh-server端<br>安装qemu相关软件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install qemu-kvm qemu-img virt-manager libvirt libvirt-python libvirt-client virt-install virt-viewer</span><br></pre></td></tr></table></figure>

<p>准备可用的qemu虚拟机镜像文件<br>条件：有一台PC机器，安装好了qemu</p>
<h3 id="新建磁盘文件"><a href="#新建磁盘文件" class="headerlink" title="新建磁盘文件"></a>新建磁盘文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-img create -f qcow2 /root/my.qcow2 20G</span><br></pre></td></tr></table></figure>

<h3 id="安装虚拟机"><a href="#安装虚拟机" class="headerlink" title="安装虚拟机"></a>安装虚拟机</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">virt-install -r 1024 –accelerate -n <span class="built_in">test</span> -f /root/my.qcow2 –cdrom mini.iso –graphics=vnc,listen=0.0.0.0</span><br></pre></td></tr></table></figure>

<p>注：mini.iso是ubuntu的最小安装盘，你可以用其他的代替</p>
<p>图形界面正常的安装流程</p>
<p>然后进入虚拟机安装openssh-server端，打开root的ssh登录权限。</p>
<p>此时，我们安装的虚拟机系统的所有文件都在/root/my.qcow2里面。所以，我们把它拷贝到你的centos上面，然后可以直接用这个镜像文件创建虚拟机了。</p>
<h2 id="启动虚拟机的xml配置文件示例"><a href="#启动虚拟机的xml配置文件示例" class="headerlink" title="启动虚拟机的xml配置文件示例"></a>启动虚拟机的xml配置文件示例</h2><p>把自己的配置写到test.xml文件，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;domain type&#x3D;’kvm’&gt;</span><br><span class="line">&lt;name&gt;test&lt;&#x2F;name&gt;</span><br><span class="line">&lt;memory unit&#x3D;’MiB’&gt;1024&lt;&#x2F;memory&gt;</span><br><span class="line">&lt;currentMemory unit&#x3D;’MiB’&gt;1024&lt;&#x2F;currentMemory&gt;</span><br><span class="line">&lt;vcpu placement&#x3D;’static’&gt;1&lt;&#x2F;vcpu&gt;</span><br><span class="line">&lt;os&gt;</span><br><span class="line">&lt;type arch&#x3D;’x86_64′ machine&#x3D;’pc’&gt;hvm&lt;&#x2F;type&gt;</span><br><span class="line">&lt;boot dev&#x3D;’cdrom’&#x2F;&gt;</span><br><span class="line">&lt;boot dev&#x3D;’hd’&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;os&gt;</span><br><span class="line">&lt;features&gt;</span><br><span class="line">&lt;acpi&#x2F;&gt;</span><br><span class="line">&lt;apic&#x2F;&gt;</span><br><span class="line">&lt;pae&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;features&gt;</span><br><span class="line">&lt;clock offset&#x3D;’utc’&#x2F;&gt;</span><br><span class="line">&lt;on_poweroff&gt;destroy&lt;&#x2F;on_poweroff&gt;</span><br><span class="line">&lt;on_reboot&gt;restart&lt;&#x2F;on_reboot&gt;</span><br><span class="line">&lt;on_crash&gt;restart&lt;&#x2F;on_crash&gt;</span><br><span class="line">&lt;devices&gt;</span><br><span class="line">&lt;emulator&gt;&#x2F;usr&#x2F;libexec&#x2F;qemu-kvm&lt;&#x2F;emulator&gt;</span><br><span class="line">&lt;disk type&#x3D;’file’ device&#x3D;’disk’&gt;</span><br><span class="line">&lt;driver name&#x3D;’qemu’ type&#x3D;’qcow2’&#x2F;&gt;</span><br><span class="line">&lt;source file&#x3D;’&#x2F;root&#x2F;guest.qcow2’&#x2F;&gt;</span><br><span class="line">&lt;target dev&#x3D;’vda’ bus&#x3D;’virtio’&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;disk&gt;</span><br><span class="line">&lt;controller type&#x3D;’usb’ index&#x3D;’0′&gt;</span><br><span class="line">&lt;&#x2F;controller&gt;</span><br><span class="line">&lt;interface type&#x3D;’network’&gt;</span><br><span class="line">&lt;mac address&#x3D;’52:54:00:00:00:12’&#x2F;&gt;</span><br><span class="line">&lt;source network&#x3D;’default’&#x2F;&gt;</span><br><span class="line">&lt;model type&#x3D;’virtio’&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;interface&gt;</span><br><span class="line">&lt;serial type&#x3D;’pty’&gt;</span><br><span class="line">&lt;target port&#x3D;’0’&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;serial&gt;</span><br><span class="line">&lt;console type&#x3D;’pty’&gt;</span><br><span class="line">&lt;target type&#x3D;’serial’ port&#x3D;’0’&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;console&gt;</span><br><span class="line">&lt;channel type&#x3D;’spicevmc’&gt;</span><br><span class="line">&lt;target type&#x3D;’virtio’ name&#x3D;’com.redhat.spice.0’&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;channel&gt;</span><br><span class="line">&lt;input type&#x3D;’tablet’ bus&#x3D;’usb’&#x2F;&gt;</span><br><span class="line">&lt;input type&#x3D;’mouse’ bus&#x3D;’ps2’&#x2F;&gt;</span><br><span class="line">&lt;input type&#x3D;’keyboard’ bus&#x3D;’ps2’&#x2F;&gt;</span><br><span class="line">&lt;graphics type&#x3D;’spice’ autoport&#x3D;’yes’&#x2F;&gt;</span><br><span class="line">&lt;sound model&#x3D;’ich6′&gt;</span><br><span class="line">&lt;&#x2F;sound&gt;</span><br><span class="line">&lt;video&gt;</span><br><span class="line">&lt;model type&#x3D;’qxl’ vram&#x3D;’9216′ heads&#x3D;’1’&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;video&gt;</span><br><span class="line">&lt;redirdev bus&#x3D;’usb’ type&#x3D;’spicevmc’&gt;</span><br><span class="line">&lt;&#x2F;redirdev&gt;</span><br><span class="line">&lt;memballoon model&#x3D;’virtio’&gt;</span><br><span class="line">&lt;&#x2F;memballoon&gt;</span><br><span class="line">&lt;&#x2F;devices&gt;</span><br><span class="line">&lt;&#x2F;domain&gt;</span><br></pre></td></tr></table></figure>

<p>注：/usr/libexec/qemu-kvm 其他系统的位置不一样（如，ubuntu是在/user/bin/qemu-system-x86_64）</p>
<p>然后直接运行virsh create test.xml，此时你就可以通过ssh root@ip到你的虚拟机上了。</p>
]]></content>
      <categories>
        <category>qemu</category>
        <category>虚拟机</category>
      </categories>
  </entry>
  <entry>
    <title>安装expect</title>
    <url>/2017/05/07/install_expect/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<h2 id="安装TCL"><a href="#安装TCL" class="headerlink" title="安装TCL"></a>安装TCL</h2><p>下载地址：<a href="http://www.tcl.tk/software/tcltk/download.html" target="_blank" rel="noopener">http://www.tcl.tk/software/tcltk/download.html</a></p>
<p>目前最新版本: tcl8.5.19-src.tar.gz</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://prdownloads.sourceforge.net/tcl/tcl8.5.19-src.tar.gz</span><br><span class="line"></span><br><span class="line">tar zxf tcl8.5.19-src.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> tcl8.5.19/unix/</span><br><span class="line"></span><br><span class="line">./configure</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h2 id="安装expect"><a href="#安装expect" class="headerlink" title="安装expect"></a>安装expect</h2><p>expect 官网：<a href="http://expect.sourceforge.net/" target="_blank" rel="noopener">http://expect.sourceforge.net/</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://nchc.dl.sourceforge.net/project/expect/Expect/5.45/expect5.45.tar.gz</span><br><span class="line"></span><br><span class="line">tar zxf expect5.45.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> expect5.45</span><br><span class="line"></span><br><span class="line">./configure  –with-tcl=/usr/<span class="built_in">local</span>/lib/ –with-tclinclude=../tcl8.5.19/generic/</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/bin/expect /usr/bin/expect</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>softwares</category>
      </categories>
  </entry>
  <entry>
    <title>Golang运行shell脚本</title>
    <url>/2017/05/07/golang_notes_run_shell_ingo/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>以获取容器ID为例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func GetContainerID() (string, error) &#123;</span><br><span class="line">cmd :&#x3D; exec.Command(“&#x2F;bin&#x2F;bash”, “-c”, “cat &#x2F;proc&#x2F;self&#x2F;cgroup | grep docker | grep -o -E ‘[0-9a-f]&#123;64&#125;’| head -n 1”)</span><br><span class="line">var out bytes.Buffer</span><br><span class="line"></span><br><span class="line">cmd.Stdout &#x3D; &amp;out</span><br><span class="line">err :&#x3D; cmd.Run()</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">return “”, err</span><br><span class="line">&#125;</span><br><span class="line">return out.String(), nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：cmd.Stdout=&amp;out把脚本执行结果重定向到指定的地方。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://c2pblog.sinaapp.com/archives/219" target="_blank" rel="noopener">http://c2pblog.sinaapp.com/archives/219</a></p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title>容器内获取容器的完整ID</title>
    <url>/2017/05/07/docker_tips_getfullcid_in_container/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<p>可以通过进程自己的cgroup的信息获取，cgroup中包含了docker容器的完整ID。在容器中运行cat /proc/self/cgroup得到如下结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@60dc9bc55a76:/home<span class="comment"># cat /proc/self/cgroup</span></span><br><span class="line">11:devices:/docker/60dc9bc55a76c81847d502d8ed432f03c6de131a85653c7a27dbe7db25b5945a</span><br><span class="line">10:cpu,cpuacct:/docker/60dc9bc55a76c81847d502d8ed432f03c6de131a85653c7a27dbe7db25b5945a</span><br><span class="line">9:blkio:/docker/60dc9bc55a76c81847d502d8ed432f03c6de131a85653c7a27dbe7db25b5945a</span><br><span class="line">8:cpuset:/docker/60dc9bc55a76c81847d502d8ed432f03c6de131a85653c7a27dbe7db25b5945a</span><br><span class="line">7:freezer:/docker/60dc9bc55a76c81847d502d8ed432f03c6de131a85653c7a27dbe7db25b5945a</span><br><span class="line">6:hugetlb:/docker/60dc9bc55a76c81847d502d8ed432f03c6de131a85653c7a27dbe7db25b5945a</span><br><span class="line">5:net_cls,net_prio:/docker/60dc9bc55a76c81847d502d8ed432f03c6de131a85653c7a27dbe7db25b5945a</span><br><span class="line">4:memory:/docker/60dc9bc55a76c81847d502d8ed432f03c6de131a85653c7a27dbe7db25b5945a</span><br><span class="line">3:pids:/docker/60dc9bc55a76c81847d502d8ed432f03c6de131a85653c7a27dbe7db25b5945a</span><br><span class="line">2:perf_event:/docker/60dc9bc55a76c81847d502d8ed432f03c6de131a85653c7a27dbe7db25b5945a</span><br><span class="line">1:name=systemd:/docker/60dc9bc55a76c81847d502d8ed432f03c6de131a85653c7a27dbe7db25b5945a</span><br></pre></td></tr></table></figure>

<p>可以通过下面的命令，提前出来docker容器ID：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /proc/self/cgroup | grep docker | grep -o -E ‘[0-9a<span class="_">-f</span>]&#123;64&#125;’ | head -n 1</span><br></pre></td></tr></table></figure>

<p>参考链接：<a href="https://github.com/docker/docker/issues/19698" target="_blank" rel="noopener">https://github.com/docker/docker/issues/19698</a></p>
]]></content>
      <categories>
        <category>docker</category>
        <category>tips</category>
      </categories>
  </entry>
  <entry>
    <title>Namespace</title>
    <url>/2017/05/07/linux_kernel_namespace/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<p>Linux支持如下的namespaces:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Namespace                            Constant                                               Isolates</span><br><span class="line"></span><br><span class="line">Cgroup                               CLONE_NEWCGROUP                                    Cgroup root directory</span><br><span class="line">IPC                                  CLONE_NEWIPC                                       System V IPC, POSIX message queues</span><br><span class="line">Network                              CLONE_NEWNET                                       Network devices, stacks, ports, etc.</span><br><span class="line">Mount                                CLONE_NEWNS                                        Mount points</span><br><span class="line">PID                                  CLONE_NEWPID                                       Process IDs</span><br><span class="line">User                                 CLONE_NEWUSER                                      User and group IDs</span><br><span class="line">UTS                                  CLONE_NEWUTS                                       Hostname and NIS domain name</span><br></pre></td></tr></table></figure>

<p>读取软链接的namespace类型和inode值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ readlink /proc/$$/ns/uts</span><br><span class="line">uts:[4026531838]</span><br></pre></td></tr></table></figure>

<p>参考链接：<a href="http://man7.org/linux/man-pages/man7/namespaces.7.html" target="_blank" rel="noopener">http://man7.org/linux/man-pages/man7/namespaces.7.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Shell</category>
        <category>namespace</category>
      </categories>
  </entry>
  <entry>
    <title>基于centos搭建wordpress的docker镜像</title>
    <url>/2017/05/07/build_wordpress_docker_image/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<h2 id="自定义的Dockerfile"><a href="#自定义的Dockerfile" class="headerlink" title="自定义的Dockerfile"></a>自定义的Dockerfile</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">ENV http_proxy http://username:password@proxy:8080</span><br><span class="line">ENV https_proxy http://username:password@proxy:8080</span><br><span class="line"></span><br><span class="line"><span class="comment">#RUN echo “http_proxy=http://username:password@proxy:8080” &gt;&gt; /etc/apt/apt.conf</span></span><br><span class="line"><span class="comment">#RUN echo “https_proxy=http://username:password@proxy:8080” &gt;&gt; /etc/apt/apt.conf</span></span><br><span class="line"></span><br><span class="line">RUN touch /etc/wgetrc</span><br><span class="line">RUN <span class="built_in">echo</span> “http_proxy=http://username:password@proxy:8080” &gt;&gt; /etc/wgetrc</span><br><span class="line">RUN <span class="built_in">echo</span> “https_proxy=http://username:password@proxy:8080” &gt;&gt; /etc/wgetrc</span><br><span class="line">RUN <span class="built_in">source</span> /etc/wgetrc</span><br><span class="line"></span><br><span class="line">RUN yum -y update</span><br><span class="line">RUN yum -y install httpd httpd-devel zip unzip tar wget</span><br><span class="line">RUN yum -y install php php-xml php-pdo php-gd php-mbstring sqlite sqlite-devel</span><br><span class="line"></span><br><span class="line">RUN wget –no-check-certificate https://wordpress.org/latest.tar.gz（中文版链接：https://cn.wordpress.org/wordpress-4.5.3-zh_CN.tar.gz）</span><br><span class="line">RUN wget –no-check-certificate https://downloads.wordpress.org/plugin/sqlite-integration.1.8.1.zip</span><br><span class="line">RUN tar xvfz ./latest.tar.gz</span><br><span class="line">RUN unzip ./sqlite-integration.1.8.1.zip</span><br><span class="line">RUN rm -f ./latest.tar.gz</span><br><span class="line">RUN rm -f ./sqlite-integration.1.8.1.zip</span><br><span class="line">RUN mv wordpress /var/lib/wordpress</span><br><span class="line">RUN chown -R apache.apache /var/lib/wordpress</span><br><span class="line">RUN mv /var/lib/wordpress/wp-config-sample.php /var/lib/wordpress/wp-config.php</span><br><span class="line">RUN mv sqlite-integration /var/lib/wordpress/wp-content/plugins/</span><br><span class="line">RUN mv /var/lib/wordpress/wp-content/plugins/sqlite-integration/db.php \</span><br><span class="line">/var/lib/wordpress/wp-content/</span><br><span class="line"></span><br><span class="line">RUN <span class="built_in">echo</span> “yes n | cp -ripf /var/lib/wordpress/* /var/www/html/ &gt; /dev/null 2&gt;&amp;1” &gt;&gt; /root/.bash_profile</span><br><span class="line">VOLUME /var/www/html</span><br><span class="line"></span><br><span class="line">RUN systemctl <span class="built_in">enable</span> httpd</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"><span class="comment">#docker run –privileged -itd -p 8080:80 -v /root/wordpress/public_html:/var/www/html wordpress_sqlite bash -l -c “/sbin/init”</span></span><br></pre></td></tr></table></figure>

<p>然后构建docker镜像，执行命令：docker build –tag wordpress_sqlite .</p>
<p>现在新建wordpress的在host上的文件目录，如：/home/rtos/workspace/wordpress/public_html/</p>
<p>启动wordpress服务，执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run –privileged -itd -p 8080:80 -v &#x2F;home&#x2F;rtos&#x2F;workspace&#x2F;wordpress&#x2F;public_html&#x2F;:&#x2F;var&#x2F;www&#x2F;html wordpress_sqlite bash -l -c “sbin&#x2F;init”</span><br><span class="line"></span><br><span class="line">等待几分钟，访问http:&#x2F;&#x2F;localhost:8080，或者http:&#x2F;&#x2F;ip:8080</span><br></pre></td></tr></table></figure>



<p>注意：</p>
<ul>
<li>我们的博客数据是放到SQLite数据库 （/var/www/html/wp-content/database/.ht.sqlite文件）</li>
<li>而网站的所有程序是放到(目录/var/www/html)</li>
<li>关于如何备份数据以及迁移博客，后续分析。</li>
</ul>
]]></content>
      <categories>
        <category>docker image</category>
        <category>WordPress</category>
      </categories>
  </entry>
  <entry>
    <title>官方镜像安装wordpress</title>
    <url>/2017/05/07/install_wordpress_docker_image/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<h2 id="拉取官方镜像"><a href="#拉取官方镜像" class="headerlink" title="拉取官方镜像"></a>拉取官方镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull wordpress:latest</span><br><span class="line">docker pull mysql:latest</span><br></pre></td></tr></table></figure>

<h2 id="启动mysql容器服务"><a href="#启动mysql容器服务" class="headerlink" title="启动mysql容器服务"></a>启动mysql容器服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run –name mysqlwp -e MYSQL_ROOT_PASSWORD=dockerRootMySQL \</span><br><span class="line">-e MYSQL_DATABASE=wordpress \</span><br><span class="line">-e MYSQL_USER=wordpress \</span><br><span class="line">-e MYSQL_PASSWORD=wordpresspwd \</span><br><span class="line">-d mysql</span><br></pre></td></tr></table></figure>

<h2 id="启动wordpress容器服务"><a href="#启动wordpress容器服务" class="headerlink" title="启动wordpress容器服务"></a>启动wordpress容器服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run –name wordpress –link mysqlwp:mysql -p 8080:80 \</span><br><span class="line">-e WORDPRESS_DB_NAME=wordpress \</span><br><span class="line">-e WORDPRESS_DB_USER=wordpress \</span><br><span class="line">-e WORDPRESS_DB_PASSWORD=wordpresspwd \</span><br><span class="line">-d wordpress</span><br></pre></td></tr></table></figure>

<p>注意：官方的安装方式，博客书籍到保存到MySQL数据库里，而我们的MySQL是放到容器里面了。怎么回去书籍，后续研究。</p>
<p>优点：构建方便、快捷</p>
<p>缺点：第一，两个容器大概需要800MB的存储空间；第二，需要启动二个容器</p>
]]></content>
      <categories>
        <category>docker image</category>
        <category>WordPress</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu搭载shadowsocks服务</title>
    <url>/2017/05/07/shadowsocks_in_ubuntu/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<h2 id="安装python和ss"><a href="#安装python和ss" class="headerlink" title="安装python和ss"></a>安装python和ss</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">apt-<span class="built_in">get</span> update</span><br><span class="line">apt-<span class="built_in">get</span> install python-pip</span><br><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure>

<h2 id="开启ss服务"><a href="#开启ss服务" class="headerlink" title="开启ss服务"></a>开启ss服务</h2><h3 id="直接前台开启"><a href="#直接前台开启" class="headerlink" title="直接前台开启"></a>直接前台开启</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssserver -p 443 -k password -m aes-256-cfb</span><br></pre></td></tr></table></figure>

<p>优点：可以看到连接输出日志<br>缺点：端口ssh连接会导致服务中断，root权限启动</p>
<h3 id="后台开启并使用其他权限启动"><a href="#后台开启并使用其他权限启动" class="headerlink" title="后台开启并使用其他权限启动"></a>后台开启并使用其他权限启动</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssserver -p 443 -k password -m aes-256-cfb –user nobody -d start</span><br></pre></td></tr></table></figure>

<p>配置文件设置服务<br>配置文件格式: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">“server”:”0.0.0.0″,</span><br><span class="line">“port_password”:&#123;</span><br><span class="line">“8381”:”haozi001″,</span><br><span class="line">“8382”:”haozi001″,</span><br><span class="line">“8383”:”haozi001″</span><br><span class="line">&#125;,</span><br><span class="line">“local_address”: “127.0.0.1”,</span><br><span class="line">“local_port”:1080,</span><br><span class="line">“timeout”:600,</span><br><span class="line">“method”:”aes-256-cfb”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：如果是在google cloud platform上面设置，需要打开设置的端口号（如8381等）</p>
<p>优点:可以同时配置多个端口和密码，支持多用户</p>
<p>启动和停止命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks.json -d start</span><br><span class="line">ssserver -c /etc/shadowsocks.json -d stop</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Ubuntu</category>
        <category>shadowsocks</category>
      </categories>
  </entry>
  <entry>
    <title>awk笔记</title>
    <url>/2017/05/07/shell_learn_awk1/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<h2 id="awk文件格式"><a href="#awk文件格式" class="headerlink" title="awk文件格式"></a>awk文件格式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\#!&#x2F;bin&#x2F;awk -f  #注意头部</span><br><span class="line"></span><br><span class="line">BEGIN &#123;</span><br><span class="line"></span><br><span class="line">\#定义初始化变量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">\#处理逻辑</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">END &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -f my.awk filename</span><br></pre></td></tr></table></figure>

<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>split( String, A, [Ere] )： 将 String 参数指定的参数分割为数组元素 A[1], A[2], . . ., A[n]，并返回 n 变量的值。此分隔可以通过 Ere 参数指定的扩展正则表达式进行，<br>或用当前字段分隔符（FS 特殊变量）来进行（如果没有给出 Ere 参数）。除非上下文指明特定的元素还应具有一个数字值，否则 A 数组中的元素用字符串值来创建。</p>
<p>split函数：以Ere分隔String并动态生成一个数组A（获取数组长度的方法，参考注意事项）。</p>
<p>substr( String, M, [ N ] ) ：返回具有 N 参数指定的字符数量子串。子串从 String 参数指定的字符串取得，其字符以 M 参数指定的位置开始。M 参数指定为将 String 参数中的第一个字符作为编号 1。<br>如果未指定 N 参数，则子串的长度将是 M 参数指定的位置到 String 参数的末尾 的长度。</p>
<p>函数substr用于截取部分字符串，注意index从1开始。 </p>
<p>````substr ( string, starting position, [ length of string ] )`</p>
<p>注意事项：</p>
<ul>
<li>length函数不能用于数组长度计算，可以通过for(k in arry) count++;</li>
<li>$1,2,3变量如果是用于字符串用途，不能用双引号括起来；</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Shell</category>
        <category>awk</category>
      </categories>
  </entry>
  <entry>
    <title>Shell逐行遍历文件</title>
    <url>/2017/05/07/shell_learn_readfile_lines/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<h2 id="while-read"><a href="#while-read" class="headerlink" title="while read"></a>while read</h2><p>read命令接收标准输入，或其他文件描述符的输入，得到输入后，read命令将数据放入一个标准变量中．</p>
<p>利用read读取文件时，每次调用read命令都会读取文件中的”一行”文本．</p>
<p>当文件没有可读的行时，read命令将以非零状态退出．</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat filename| <span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> “<span class="variable">$&#123;line&#125;</span>”</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> “<span class="variable">$&#123;line&#125;</span>”</span><br><span class="line"><span class="keyword">done</span> &lt; filename</span><br></pre></td></tr></table></figure>

<h2 id="for-var-in-file"><a href="#for-var-in-file" class="headerlink" title="for  var in file"></a>for  var in file</h2><p>for var in file　表示变量var在file中循环取值．取值的分隔符由$IFS确定．</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for line in $(cat filename)</span><br><span class="line">do</span><br><span class="line">echo “File:$&#123;line&#125;”</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">for line in &#96;cat filename&#96;</span><br><span class="line">do</span><br><span class="line">echo “$&#123;line&#125;”</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>如果输入文本每行中没有空格，则line在输入文本中按换行符分隔符循环取值．</p>
<p>如果输入文本中包括空格或制表符，则不是换行读取，line在输入文本中按空格分隔符或制表符或换行符特环取值．</p>
<p>可以通过把IFS设置为换行符来达到逐行读取的功能．</p>
<p>IFS的默认值为：空白(包括：空格，制表符，换行符)．</p>
<p>注意：如何设置IFS为换行符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OLD_IFS&#x3D;”$IFS”</span><br><span class="line">IFS&#x3D;$’\x0A’</span><br></pre></td></tr></table></figure>

<h2 id="awk工具变量"><a href="#awk工具变量" class="headerlink" title="awk工具变量"></a>awk工具变量</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -f my.awk filename</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>Shell</category>
      </categories>
  </entry>
  <entry>
    <title>docker命令分析--权限管理</title>
    <url>/2017/03/01/docker_cmd_analyse3_1_1/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<p>所有命令均基于docker1.11版本</p>
<h1 id="运行时特权和Linux能力"><a href="#运行时特权和Linux能力" class="headerlink" title="运行时特权和Linux能力"></a>运行时特权和Linux能力</h1><p>run命令与特权相关的几个选项：</p>
<ul>
<li>–cap-add: Add Linux capabilities</li>
<li>–cap-drop: Drop Linux capabilities</li>
<li>–privileged=false: Give extended privileges to this container</li>
<li>–device=[]: Allows you to run devices inside the container without the –privileged flag.</li>
</ul>
<p>注：默认的容器都是unprivileged，因此很多系统调用、设备等特权相关的操作都是干不了的。而且1.10版本之后增加了seccomp安全控制，<br>    可能导致容器有了权限，但是一些系统调用被安全策略禁止了。关于安全策略seccomp可以参考文档<a href="/2017/03/01/docker_cmd_analyse3_1_2/">Docker安全策略</a></p>
<p>docker run –privileged启动的容器，具有访问host上所有设备的能力，当然需要同时设置AppArmor或者SELinux允许容器相同的权限。</p>
<p>–device可以指定一个或者多个设备在容器中能正常使用，默认情况，容器对这些设备具有read、write和mknod的权限，这些权限可以通过”:rwm”来修改。<br>mknod可以参考<a href="http://www.cnblogs.com/hnrainll/archive/2011/06/10/2077583.html" target="_blank" rel="noopener">这篇博客</a></p>
<p>示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run --device&#x3D;&#x2F;dev&#x2F;sda:&#x2F;dev&#x2F;xvdc --rm -it ubuntu fdisk  &#x2F;dev&#x2F;xvdc</span><br><span class="line"></span><br><span class="line">Command (m for help): q</span><br><span class="line">$ docker run --device&#x3D;&#x2F;dev&#x2F;sda:&#x2F;dev&#x2F;xvdc:r --rm -it ubuntu fdisk  &#x2F;dev&#x2F;xvdc</span><br><span class="line">You will not be able to write the partition table.</span><br><span class="line"></span><br><span class="line">Command (m for help): q</span><br><span class="line"></span><br><span class="line">$ docker run --device&#x3D;&#x2F;dev&#x2F;sda:&#x2F;dev&#x2F;xvdc:w --rm -it ubuntu fdisk  &#x2F;dev&#x2F;xvdc</span><br><span class="line">    crash....</span><br><span class="line"></span><br><span class="line">$ docker run --device&#x3D;&#x2F;dev&#x2F;sda:&#x2F;dev&#x2F;xvdc:m --rm -it ubuntu fdisk  &#x2F;dev&#x2F;xvdc</span><br><span class="line">fdisk: unable to open &#x2F;dev&#x2F;xvdc: Operation not permitted</span><br></pre></td></tr></table></figure>

<p>相对于privileged的暴力权限，cap-add和cap-drop对权限的控制更细腻。<br>Docker目前支持的权限设置列表如下：</p>
<table>
<thead>
<tr>
<th>Capability Key</th>
<th>Capability Description</th>
</tr>
</thead>
<tbody><tr>
<td>SETPCAP</td>
<td>Modify process capabilities.</td>
</tr>
<tr>
<td>SYS_MODULE</td>
<td>Load and unload kernel modules.</td>
</tr>
<tr>
<td>SYS_RAWIO</td>
<td>Perform I/O port operations (iopl(2) and ioperm(2)).</td>
</tr>
<tr>
<td>SYS_PACCT</td>
<td>Use acct(2), switch process accounting on or off.</td>
</tr>
<tr>
<td>SYS_ADMIN</td>
<td>Perform a range of system administration operations.</td>
</tr>
<tr>
<td>SYS_NICE</td>
<td>Raise process nice value (nice(2), setpriority(2)) and change the nice value for arbitrary processes.</td>
</tr>
<tr>
<td>SYS_RESOURCE</td>
<td>Override resource Limits.</td>
</tr>
<tr>
<td>SYS_TIME</td>
<td>Set system clock (settimeofday(2), stime(2), adjtimex(2)); set real-time (hardware) clock.</td>
</tr>
<tr>
<td>SYS_TTY_CONFIG</td>
<td>Use vhangup(2); employ various privileged ioctl(2) operations on virtual terminals.</td>
</tr>
<tr>
<td>MKNOD</td>
<td>Create special files using mknod(2).</td>
</tr>
<tr>
<td>AUDIT_WRITE</td>
<td>Write records to kernel auditing log.</td>
</tr>
<tr>
<td>AUDIT_CONTROL</td>
<td>Enable and disable kernel auditing; change auditing filter rules; retrieve auditing status and filtering rules.</td>
</tr>
<tr>
<td>MAC_OVERRIDE</td>
<td>Allow MAC configuration or state changes. Implemented for the Smack LSM.</td>
</tr>
<tr>
<td>MAC_ADMIN</td>
<td>Override Mandatory Access Control (MAC). Implemented for the Smack Linux Security Module (LSM).</td>
</tr>
<tr>
<td>NET_ADMIN</td>
<td>Perform various network-related operations.</td>
</tr>
<tr>
<td>SYSLOG</td>
<td>Perform privileged syslog(2) operations.</td>
</tr>
<tr>
<td>CHOWN</td>
<td>Make arbitrary changes to file UIDs and GIDs (see chown(2)).</td>
</tr>
<tr>
<td>NET_RAW</td>
<td>Use RAW and PACKET sockets.</td>
</tr>
<tr>
<td>DAC_OVERRIDE</td>
<td>Bypass file read, write, and execute permission checks.</td>
</tr>
<tr>
<td>FOWNER</td>
<td>Bypass permission checks on operations that normally require the file system UID of the process to match the UID of the file.</td>
</tr>
<tr>
<td>DAC_READ_SEARCH</td>
<td>Bypass file read permission checks and directory read and execute permission checks.</td>
</tr>
<tr>
<td>FSETID</td>
<td>Don’t clear set-user-ID and set-group-ID permission bits when a file is modified.</td>
</tr>
<tr>
<td>KILL</td>
<td>Bypass permission checks for sending signals.</td>
</tr>
<tr>
<td>SETGID</td>
<td>Make arbitrary manipulations of process GIDs and supplementary GID list.</td>
</tr>
<tr>
<td>SETUID</td>
<td>Make arbitrary manipulations of process UIDs.</td>
</tr>
<tr>
<td>LINUX_ IMMUTABLE</td>
<td>Set the FS_APPEND_FL and FS_IMMUTABLE_FL i-node flags.</td>
</tr>
<tr>
<td>NET_BIND_SERVICE</td>
<td>Bind a socket to internet domain privileged ports (port numbers less than 1024).</td>
</tr>
<tr>
<td>NET_BROADCAST</td>
<td>Make socket broadcasts, and listen to multicasts.</td>
</tr>
<tr>
<td>IPC_LOCK</td>
<td>Lock memory (mlock(2), mlockall(2), mmap(2), shmctl(2)).</td>
</tr>
<tr>
<td>IPC_OWNER</td>
<td>Bypass permission checks for operations on System V IPC objects.</td>
</tr>
<tr>
<td>SYS_CHROOT</td>
<td>Use chroot(2), change root directory.</td>
</tr>
<tr>
<td>SYS_PTRACE</td>
<td>Trace arbitrary processes using ptrace(2).</td>
</tr>
<tr>
<td>SYS_ BOOT</td>
<td>Use reboot(2) and kexec_load(2), reboot and load a new kernel for later execution.</td>
</tr>
<tr>
<td>LEASE</td>
<td>Establish leases on arbitrary files (see fcntl(2)).</td>
</tr>
<tr>
<td>SETFCAP</td>
<td>Set file capabilities.</td>
</tr>
<tr>
<td>WAKE_ALARM</td>
<td>Trigger something that will wake up the system.</td>
</tr>
<tr>
<td>BLOCK_SUSPEND</td>
<td>Employ features that can block system suspend.</td>
</tr>
</tbody></table>
<p>cap-add和cap-drop都支持ALL，表示加上或者去掉所有能力。例如，加上所有能力，但是去掉MKNOD：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run --cap-add&#x3D;ALL --cap-drop&#x3D;MKNOD ...</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>docker</category>
        <category>docker命令</category>
      </categories>
  </entry>
  <entry>
    <title>docker命令分析--Seccomp特性</title>
    <url>/2017/03/01/docker_cmd_analyse3_1_2/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<p>Secure computing mode (Seccomp)是Linux内核的特性。可以使用Seccomp来限制容器内的行为。<br>该特性的有效基于：</p>
<ul>
<li>Docker编译时加上了seccomp</li>
<li>内核打开了CONFIG_SECCOMP配置</li>
</ul>
<h2 id="修改默认Seccomp配置文件"><a href="#修改默认Seccomp配置文件" class="headerlink" title="修改默认Seccomp配置文件"></a>修改默认Seccomp配置文件</h2><p><a href="https://github.com/docker/docker/blob/master/profiles/seccomp/default.json" target="_blank" rel="noopener">默认的Seccomp配置文件</a>禁止了44个系统调用。<br>可以参考默认的配置文件，自定义然后在docker run的时候用–security-opt设置自定义的配置文件，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run --rm -it --security-opt seccomp&#x3D;&#x2F;path&#x2F;to&#x2F;seccomp&#x2F;profile.json hello-world</span><br></pre></td></tr></table></figure>
<p>默认的Seccomp配置文件是一个白名单，没有指定的则是被禁止的。下表给出一些被禁止的系统调用（不是全部），以及原因。</p>
<table>
<thead>
<tr>
<th>Syscall</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>acct</td>
<td>Accounting syscall which could let containers disable their own resource limits or process accounting. Also gated by CAP_SYS_PACCT.</td>
</tr>
<tr>
<td>add_key</td>
<td>Prevent containers from using the kernel keyring, which is not namespaced.</td>
</tr>
<tr>
<td>adjtimex</td>
<td>Similar to clock_settime and settimeofday, time/date is not namespaced. Also gated by CAP_SYS_TIME.</td>
</tr>
<tr>
<td>bpf</td>
<td>Deny loading potentially persistent bpf programs into kernel, already gated by CAP_SYS_ADMIN.</td>
</tr>
<tr>
<td>clock_ adjtime</td>
<td>Time/date is not namespaced. Also gated by CAP_SYS_TIME.</td>
</tr>
<tr>
<td>clock_ settime</td>
<td>Time/date is not namespaced. Also gated by CAP_SYS_TIME.</td>
</tr>
<tr>
<td>clone</td>
<td>Deny cloning new namespaces. Also gated by CAP_SYS_ADMIN for CLONE_* flags, except CLONE_USERNS.</td>
</tr>
<tr>
<td>create_ module</td>
<td>Deny manipulation and functions on kernel modules. Obsolete. Also gated by CAP_SYS_MODULE.</td>
</tr>
<tr>
<td>delete_ module</td>
<td>Deny manipulation and functions on kernel modules. Also gated by CAP_SYS_MODULE.</td>
</tr>
<tr>
<td>finit_ module</td>
<td>Deny manipulation and functions on kernel modules. Also gated by CAP_SYS_MODULE.</td>
</tr>
<tr>
<td>get_kernel_syms</td>
<td>Deny retrieval of exported kernel and module symbols. Obsolete.</td>
</tr>
<tr>
<td>get_ mempolicy</td>
<td>Syscall that modifies kernel memory and NUMA settings. Already gated by CAP_SYS_NICE.</td>
</tr>
<tr>
<td>init_ module</td>
<td>Deny manipulation and functions on kernel modules. Also gated by CAP_SYS_MODULE.</td>
</tr>
<tr>
<td>ioperm</td>
<td>Prevent containers from modifying kernel I/O privilege levels. Already gated by CAP_SYS_RAWIO.</td>
</tr>
<tr>
<td>iopl</td>
<td>Prevent containers from modifying kernel I/O privilege levels. Already gated by CAP_SYS_RAWIO.</td>
</tr>
<tr>
<td>kcmp</td>
<td>Restrict process inspection capabilities, already blocked by dropping CAP_PTRACE.</td>
</tr>
<tr>
<td>kexec_file_load</td>
<td>Sister syscall of kexec_load that does the same thing, slightly different arguments. Also gated by CAP_SYS_BOOT.</td>
</tr>
<tr>
<td>kexec_ load</td>
<td>Deny loading a new kernel for later execution. Also gated by CAP_SYS_BOOT.</td>
</tr>
<tr>
<td>keyctl</td>
<td>Prevent containers from using the kernel keyring, which is not namespaced.</td>
</tr>
<tr>
<td>lookup_ dcookie</td>
<td>Tracing/profiling syscall, which could leak a lot of information on the host. Also gated by CAP_SYS_ADMIN.</td>
</tr>
<tr>
<td>mbind</td>
<td>Syscall that modifies kernel memory and NUMA settings. Already gated by CAP_SYS_NICE.</td>
</tr>
<tr>
<td>mount</td>
<td>Deny mounting, already gated by CAP_SYS_ADMIN.</td>
</tr>
<tr>
<td>move_pages</td>
<td>Syscall that modifies kernel memory and NUMA settings.</td>
</tr>
<tr>
<td>name_to_handle_at</td>
<td>Sister syscall to open_by_handle_at. Already gated by CAP_SYS_NICE.</td>
</tr>
<tr>
<td>nfsservctl</td>
<td>Deny interaction with the kernel nfs daemon. Obsolete since Linux 3.1.</td>
</tr>
<tr>
<td>open_by_handle_at</td>
<td>Cause of an old container breakout. Also gated by CAP_DAC_READ_SEARCH.</td>
</tr>
<tr>
<td>perf_event_open</td>
<td>Tracing/profiling syscall, which could leak a lot of information on the host.</td>
</tr>
<tr>
<td>personality</td>
<td>Prevent container from enabling BSD emulation. Not inherently dangerous, but poorly tested, potential for a lot of kernel vulns.</td>
</tr>
<tr>
<td>pivot_ root</td>
<td>Deny pivot_root, should be privileged operation.</td>
</tr>
<tr>
<td>process_vm_readv</td>
<td>Restrict process inspection capabilities, already blocked by dropping CAP_PTRACE.</td>
</tr>
<tr>
<td>process_vm_writev</td>
<td>Restrict process inspection capabilities, already blocked by dropping CAP_PTRACE.</td>
</tr>
<tr>
<td>ptrace</td>
<td>Tracing/profiling syscall, which could leak a lot of information on the host. Already blocked by dropping CAP_PTRACE.</td>
</tr>
<tr>
<td>query_module</td>
<td>Deny manipulation and functions on kernel modules. Obsolete.</td>
</tr>
<tr>
<td>quotactl</td>
<td>Quota syscall which could let containers disable their own resource limits or process accounting. Also gated by CAP_SYS_ADMIN.</td>
</tr>
<tr>
<td>reboot</td>
<td>Don’t let containers reboot the host. Also gated by CAP_SYS_BOOT.</td>
</tr>
<tr>
<td>request_key</td>
<td>Prevent containers from using the kernel keyring, which is not namespaced.</td>
</tr>
<tr>
<td>set_ mempolicy</td>
<td>Syscall that modifies kernel memory and NUMA settings. Already gated by CAP_SYS_NICE.</td>
</tr>
<tr>
<td>setns</td>
<td>Deny associating a thread with a namespace. Also gated by CAP_SYS_ADMIN.</td>
</tr>
<tr>
<td>settimeofday</td>
<td>Time/date is not namespaced. Also gated by CAP_SYS_TIME.</td>
</tr>
<tr>
<td>stime</td>
<td>Time/date is not namespaced. Also gated by CAP_SYS_TIME.</td>
</tr>
<tr>
<td>swapon</td>
<td>Deny start/stop swapping to file/device. Also gated by CAP_SYS_ADMIN.</td>
</tr>
<tr>
<td>swapoff</td>
<td>Deny start/stop swapping to file/device. Also gated by CAP_SYS_ADMIN.</td>
</tr>
<tr>
<td>sysfs</td>
<td>Obsolete syscall.</td>
</tr>
<tr>
<td>_sysctl</td>
<td>Obsolete, replaced by /proc/sys.</td>
</tr>
<tr>
<td>umount</td>
<td>Should be a privileged operation. Also gated by CAP_SYS_ADMIN.</td>
</tr>
<tr>
<td>umount2</td>
<td>Should be a privileged operation. Also gated by CAP_SYS_ADMIN.</td>
</tr>
<tr>
<td>unshare</td>
<td>Deny cloning new namespaces for processes. Also gated by CAP_SYS_ADMIN, with the exception of unshare –user.</td>
</tr>
<tr>
<td>uselib</td>
<td>Older syscall related to shared libraries, unused for a long time.</td>
</tr>
<tr>
<td>userfaultfd</td>
<td>Userspace page fault handling, largely needed for process migration.</td>
</tr>
<tr>
<td>ustat</td>
<td>Obsolete syscall.</td>
</tr>
<tr>
<td>vm86</td>
<td>In kernel x86 real mode virtual machine. Also gated by CAP_SYS_ADMIN.</td>
</tr>
<tr>
<td>vm86old</td>
<td>In kernel x86 real mode virtual machine. Also gated by CAP_SYS_ADMIN.</td>
</tr>
</tbody></table>
<h2 id="禁用Seccomp"><a href="#禁用Seccomp" class="headerlink" title="禁用Seccomp"></a>禁用Seccomp</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run --rm -it --security-opt seccomp&#x3D;unconfined debian:jessie \</span><br><span class="line">    unshare --map-root-user --user sh -c whoami</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>docker</category>
        <category>docker命令</category>
      </categories>
  </entry>
  <entry>
    <title>docker命令分析--run命令</title>
    <url>/2017/03/01/docker_cmd_analyse3_1/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<p>所有命令均基于docker1.11版本</p>
<p>容器最常用，也最复杂的命令应该是run命令了，这篇文章主要对docker run进行简单的分析。</p>
<h2 id="使用手册"><a href="#使用手册" class="headerlink" title="使用手册"></a>使用手册</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line">Run a command in a new container</span><br><span class="line"></span><br><span class="line">  -a, --attach&#x3D;[]               Attach to STDIN, STDOUT or STDERR</span><br><span class="line">  --add-host&#x3D;[]                 Add a custom host-to-IP mapping (host:ip)</span><br><span class="line">  --blkio-weight&#x3D;0              Block IO weight (relative weight)</span><br><span class="line">  --blkio-weight-device&#x3D;[]      Block IO weight (relative device weight, format: &#96;DEVICE_NAME:WEIGHT&#96;)</span><br><span class="line">  --cpu-shares&#x3D;0                CPU shares (relative weight)</span><br><span class="line">  --cap-add&#x3D;[]                  Add Linux capabilities</span><br><span class="line">  --cap-drop&#x3D;[]                 Drop Linux capabilities</span><br><span class="line">  --cgroup-parent&#x3D;&quot;&quot;            Optional parent cgroup for the container</span><br><span class="line">  --cidfile&#x3D;&quot;&quot;                  Write the container ID to the file</span><br><span class="line">  --cpu-period&#x3D;0                Limit CPU CFS (Completely Fair Scheduler) period</span><br><span class="line">  --cpu-quota&#x3D;0                 Limit CPU CFS (Completely Fair Scheduler) quota</span><br><span class="line">  --cpuset-cpus&#x3D;&quot;&quot;              CPUs in which to allow execution (0-3, 0,1)</span><br><span class="line">  --cpuset-mems&#x3D;&quot;&quot;              Memory nodes (MEMs) in which to allow execution (0-3, 0,1)</span><br><span class="line">  -d, --detach                  Run container in background and print container ID</span><br><span class="line">  --detach-keys                 Specify the escape key sequence used to detach a container</span><br><span class="line">  --device&#x3D;[]                   Add a host device to the container</span><br><span class="line">  --device-read-bps&#x3D;[]          Limit read rate (bytes per second) from a device (e.g., --device-read-bps&#x3D;&#x2F;dev&#x2F;sda:1mb)</span><br><span class="line">  --device-read-iops&#x3D;[]         Limit read rate (IO per second) from a device (e.g., --device-read-iops&#x3D;&#x2F;dev&#x2F;sda:1000)</span><br><span class="line">  --device-write-bps&#x3D;[]         Limit write rate (bytes per second) to a device (e.g., --device-write-bps&#x3D;&#x2F;dev&#x2F;sda:1mb)</span><br><span class="line">  --device-write-iops&#x3D;[]        Limit write rate (IO per second) to a device (e.g., --device-write-bps&#x3D;&#x2F;dev&#x2F;sda:1000)</span><br><span class="line">  --disable-content-trust&#x3D;true  Skip image verification</span><br><span class="line">  --dns&#x3D;[]                      Set custom DNS servers</span><br><span class="line">  --dns-opt&#x3D;[]                  Set custom DNS options</span><br><span class="line">  --dns-search&#x3D;[]               Set custom DNS search domains</span><br><span class="line">  -e, --env&#x3D;[]                  Set environment variables</span><br><span class="line">  --entrypoint&#x3D;&quot;&quot;               Overwrite the default ENTRYPOINT of the image</span><br><span class="line">  --env-file&#x3D;[]                 Read in a file of environment variables</span><br><span class="line">  --expose&#x3D;[]                   Expose a port or a range of ports</span><br><span class="line">  --group-add&#x3D;[]                Add additional groups to run as</span><br><span class="line">  -h, --hostname&#x3D;&quot;&quot;             Container host name</span><br><span class="line">  --help                        Print usage</span><br><span class="line">  -i, --interactive             Keep STDIN open even if not attached</span><br><span class="line">  --ip&#x3D;&quot;&quot;                       Container IPv4 address (e.g. 172.30.100.104)</span><br><span class="line">  --ip6&#x3D;&quot;&quot;                      Container IPv6 address (e.g. 2001:db8::33)</span><br><span class="line">  --ipc&#x3D;&quot;&quot;                      IPC namespace to use</span><br><span class="line">  --isolation&#x3D;&quot;&quot;                Container isolation technology</span><br><span class="line">  --kernel-memory&#x3D;&quot;&quot;            Kernel memory limit</span><br><span class="line">  -l, --label&#x3D;[]                Set metadata on the container (e.g., --label&#x3D;com.example.key&#x3D;value)</span><br><span class="line">  --label-file&#x3D;[]               Read in a file of labels (EOL delimited)</span><br><span class="line">  --link&#x3D;[]                     Add link to another container</span><br><span class="line">  --log-driver&#x3D;&quot;&quot;               Logging driver for container</span><br><span class="line">  --log-opt&#x3D;[]                  Log driver specific options</span><br><span class="line">  -m, --memory&#x3D;&quot;&quot;               Memory limit</span><br><span class="line">  --mac-address&#x3D;&quot;&quot;              Container MAC address (e.g. 92:d0:c6:0a:29:33)</span><br><span class="line">  --memory-reservation&#x3D;&quot;&quot;       Memory soft limit</span><br><span class="line">  --memory-swap&#x3D;&quot;&quot;              A positive integer equal to memory plus swap. Specify -1 to enable unlimited swap.</span><br><span class="line">  --memory-swappiness&#x3D;&quot;&quot;        Tune a container&#39;s memory swappiness behavior. Accepts an integer between 0 and 100.</span><br><span class="line">  --name&#x3D;&quot;&quot;                     Assign a name to the container</span><br><span class="line">  --net&#x3D;&quot;bridge&quot;                Connect a container to a network</span><br><span class="line">                                &#39;bridge&#39;: create a network stack on the default Docker bridge</span><br><span class="line">                                &#39;none&#39;: no networking</span><br><span class="line">                                &#39;container:&lt;name|id&gt;&#39;: reuse another container&#39;s network stack</span><br><span class="line">                                &#39;host&#39;: use the Docker host network stack</span><br><span class="line">                                &#39;&lt;network-name&gt;|&lt;network-id&gt;&#39;: connect to a user-defined network</span><br><span class="line">  --net-alias&#x3D;[]                Add network-scoped alias for the container</span><br><span class="line">  --oom-kill-disable            Whether to disable OOM Killer for the container or not</span><br><span class="line">  --oom-score-adj&#x3D;0             Tune the host&#39;s OOM preferences for containers (accepts -1000 to 1000)</span><br><span class="line">  -P, --publish-all             Publish all exposed ports to random ports</span><br><span class="line">  -p, --publish&#x3D;[]              Publish a container&#39;s port(s) to the host</span><br><span class="line">  --pid&#x3D;&quot;&quot;                      PID namespace to use</span><br><span class="line">  --pids-limit&#x3D;-1                Tune container pids limit (set -1 for unlimited), kernel &gt;&#x3D; 4.3</span><br><span class="line">  --privileged                  Give extended privileges to this container</span><br><span class="line">  --read-only                   Mount the container&#39;s root filesystem as read only</span><br><span class="line">  --restart&#x3D;&quot;no&quot;                Restart policy (no, on-failure[:max-retry], always, unless-stopped)</span><br><span class="line">  --rm                          Automatically remove the container when it exits</span><br><span class="line">  --shm-size&#x3D;[]                 Size of &#96;&#x2F;dev&#x2F;shm&#96;. The format is &#96;&lt;number&gt;&lt;unit&gt;&#96;. &#96;number&#96; must be greater than &#96;0&#96;.  Unit is optional and can be &#96;b&#96; (bytes), &#96;k&#96; (kilobytes), &#96;m&#96; (megabytes), or &#96;g&#96; (gigabytes). If you omit the unit, the system uses bytes. If you omit the size entirely, the system uses &#96;64m&#96;.</span><br><span class="line">  --security-opt&#x3D;[]             Security Options</span><br><span class="line">  --sig-proxy&#x3D;true              Proxy received signals to the process</span><br><span class="line">  --stop-signal&#x3D;&quot;SIGTERM&quot;       Signal to stop a container</span><br><span class="line">  -t, --tty                     Allocate a pseudo-TTY</span><br><span class="line">  -u, --user&#x3D;&quot;&quot;                 Username or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;])</span><br><span class="line">  --userns&#x3D;&quot;&quot;                   Container user namespace</span><br><span class="line">                                &#39;host&#39;: Use the Docker host user namespace</span><br><span class="line">                                &#39;&#39;: Use the Docker daemon user namespace specified by &#96;--userns-remap&#96; option.</span><br><span class="line">  --ulimit&#x3D;[]                   Ulimit options</span><br><span class="line">  --uts&#x3D;&quot;&quot;                      UTS namespace to use</span><br><span class="line">  -v, --volume&#x3D;[host-src:]container-dest[:&lt;options&gt;]</span><br><span class="line">                                Bind mount a volume. The comma-delimited</span><br><span class="line">                                &#96;options&#96; are [rw|ro], [z|Z],</span><br><span class="line">                                [[r]shared|[r]slave|[r]private], and</span><br><span class="line">                                [nocopy]. The &#39;host-src&#39; is an absolute path</span><br><span class="line">                                or a name value.</span><br><span class="line">  --volume-driver&#x3D;&quot;&quot;            Container&#39;s volume driver</span><br><span class="line">  --volumes-from&#x3D;[]             Mount volumes from the specified container(s)</span><br><span class="line">  -w, --workdir&#x3D;&quot;&quot;              Working directory inside the container</span><br></pre></td></tr></table></figure>

<p>上面的手册可以使用“docker run –help”或者到<a href="https://docs.docker.com/v1.11/engine/reference/commandline/run/" target="_blank" rel="noopener">Docker官网</a>查看。<br>run用于在新容器中执行一条命令，首先会创建一个新容器然后执行一条指令，其实这里包含了create、start以及exec命令的作用。<br>基本用法是：“docker run [OPTIONS] IMAGE [COMMAND] [ARG…]”<br>注：</p>
<ul>
<li>可选选项OPTIONS：run具有丰富的选项，可以设置容器的一些特性</li>
<li>IMAGE：指定容器运行的基础镜像</li>
<li>可选命令COMMAND：容器运行时执行的命令</li>
<li>可选参数ARG：命令带的参数</li>
</ul>
<h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><h3 id="指定容器名并分配伪终端"><a href="#指定容器名并分配伪终端" class="headerlink" title="指定容器名并分配伪终端"></a>指定容器名并分配伪终端</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run --name hello -it ubuntu</span><br><span class="line">root@a37b3b659c24:&#x2F;#</span><br><span class="line">root@a37b3b659c24:&#x2F;#</span><br></pre></td></tr></table></figure>
<p>创建一个名字为hello的容器，并且分配一个伪终端，-i链接到容器的STDIN。</p>
<h3 id="获取容器ID-–cidfile"><a href="#获取容器ID-–cidfile" class="headerlink" title="获取容器ID(–cidfile)"></a>获取容器ID(–cidfile)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run --cidfile .&#x2F;test.cid --name hello ubuntu</span><br><span class="line">$ cat test.cid</span><br><span class="line">b504823b5a2d281e0f8ee329e14a8052bbeb171f7e50720fe0dab98ebd75587fV2R1C00B003</span><br><span class="line">$ docker run --cidfile .&#x2F;test.cid --name hello ubuntu</span><br><span class="line">docker: Container ID file found, make sure the other container isn&#39;t running or delete .&#x2F;test.cid.</span><br><span class="line">See &#39;docker run --help&#39;.</span><br></pre></td></tr></table></figure>
<p>通过–cidfile指定写入容器ID的文件路径，如果test.cid文件存在，命令会返回错误。</p>
<h3 id="特权容器"><a href="#特权容器" class="headerlink" title="特权容器"></a>特权容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run -t -i --rm ubuntu bash</span><br><span class="line">root@bc338942ef20:&#x2F;# mount -t tmpfs none &#x2F;mnt</span><br><span class="line">mount: permission denied</span><br></pre></td></tr></table></figure>
<p>默认，大部分危险的内核能力是对容器关闭的，因此上面执行失败。关于具体权限分析，参考<a href="">run的权限设置文章</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run -t -i --privileged ubuntu bash</span><br><span class="line">root@50e3f57e16e6:&#x2F;# mount -t tmpfs none &#x2F;mnt</span><br><span class="line">root@50e3f57e16e6:&#x2F;# df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">none            1.9G     0  1.9G   0% &#x2F;mnt</span><br></pre></td></tr></table></figure>
<p>–privileged选项会赋给容器所有的能力，此时的容器具有和host相同的能力，这种用法是很危险，不建议这么使用。<br>细分权限，可以参考<a href="/2017/03/01/docker_cmd_analyse3_1_1/">run的权限设置文章</a>。</p>
<h3 id="设置工作目录"><a href="#设置工作目录" class="headerlink" title="设置工作目录"></a>设置工作目录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run --rm --name hello -it ubuntu pwd</span><br><span class="line">&#x2F;</span><br><span class="line">$ docker run -w &#x2F;test --rm --name hello -it ubuntu pwd</span><br><span class="line">&#x2F;test</span><br></pre></td></tr></table></figure>
<p>默认情况下，容器的工作目录是根目录，-w可以设置该目录，如果该目录不存在，docker会在容器中创建该目录。</p>
<h3 id="挂载数据卷"><a href="#挂载数据卷" class="headerlink" title="挂载数据卷"></a>挂载数据卷</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--volume&#x3D;[host-src:]container-dest[:&lt;options&gt;]</span><br><span class="line">     Bind mount a volume. The comma-delimited</span><br><span class="line">     &#96;options&#96; are [rw|ro], [z|Z],</span><br><span class="line">     [[r]shared|[r]slave|[r]private], and</span><br><span class="line">     [nocopy]. The &#39;host-src&#39; is an absolute path</span><br><span class="line">     or a name value.</span><br></pre></td></tr></table></figure>

<p>可以把host上的文件或者目录透传到容器内指定路径，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker  run  -v &#96;pwd&#96;:&#96;pwd&#96; -w &#96;pwd&#96; -i -t  ubuntu pwd</span><br><span class="line">$ docker run -t -i -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock -v &#x2F;path&#x2F;to&#x2F;static-docker-binary:&#x2F;usr&#x2F;bin&#x2F;docker busybox sh</span><br></pre></td></tr></table></figure>
<p>可以设置容器内对该数据卷的读写权限。</p>
<p>可以从另外的容器挂载数据卷：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run --volumes-from 777f7dc92da7 --volumes-from ba8c0c54f0f2:ro -i -t ubuntu pwd</span><br></pre></td></tr></table></figure>

<h3 id="设置容器的元数据"><a href="#设置容器的元数据" class="headerlink" title="设置容器的元数据"></a>设置容器的元数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run -l my-label --label com.example.foo&#x3D;bar ubuntu bash</span><br><span class="line">$ docker run --label-file .&#x2F;labels ubuntu bash</span><br></pre></td></tr></table></figure>
<p>三种方式设置：-l、–label以及–label-file。<br>label的格式为key=value，可以没有value，如果key相同，value不同，后面的会覆盖前面的value。</p>
<h3 id="透传设备到容器"><a href="#透传设备到容器" class="headerlink" title="透传设备到容器"></a>透传设备到容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run --device&#x3D;&#x2F;dev&#x2F;sdc:&#x2F;dev&#x2F;xvdc --device&#x3D;&#x2F;dev&#x2F;sdd --device&#x3D;&#x2F;dev&#x2F;zero:&#x2F;dev&#x2F;nulo -i -t ubuntu ls -l &#x2F;dev&#x2F;&#123;xvdc,sdd,nulo&#125;</span><br><span class="line">brw-rw---- 1 root disk 8, 2 Feb  9 16:05 &#x2F;dev&#x2F;xvdc</span><br><span class="line">brw-rw---- 1 root disk 8, 3 Feb  9 16:05 &#x2F;dev&#x2F;sdd</span><br><span class="line">crw-rw-rw- 1 root root 1, 5 Feb  9 16:05 &#x2F;dev&#x2F;nulo</span><br></pre></td></tr></table></figure>
<p>–device可以把host的设备透传到容器。</p>
<h3 id="设置容器的ulimit"><a href="#设置容器的ulimit" class="headerlink" title="设置容器的ulimit"></a>设置容器的ulimit</h3><p>ulimit可以设置soft和hard限制，格式如：<type>=<soft limit>[:<hard limit>]<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run --ulimit nofile&#x3D;1024:1024 --rm ubuntu sh -c &quot;ulimit -n&quot;</span><br><span class="line">1024</span><br><span class="line">$ docker run --rm ubuntu sh -c &quot;ulimit -n&quot;</span><br><span class="line">1048576</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>如果没有指定hard limit，那么soft limit的值也会被设置给hard limit</li>
<li>如果没有设置ulimit，继承daemon设置的默认ulimit</li>
</ul>
<h3 id="退出自动清理容器"><a href="#退出自动清理容器" class="headerlink" title="退出自动清理容器"></a>退出自动清理容器</h3><p>默认情况下，容器退出后，容器的数据都是保存的。如果要删除退出不用的容器，需要手动用rm命令删除。<br>有时候，可能容器退出就没有意义了，可以设置–rm，保证容器退出之后，会被自动清理掉。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --rm ubuntu sh -c &quot;ulimit -n&quot;</span><br></pre></td></tr></table></figure>

<p>注意：不能和-d一起使用</p>
]]></content>
      <categories>
        <category>docker</category>
        <category>docker命令</category>
      </categories>
  </entry>
  <entry>
    <title>docker命令分析--其他</title>
    <url>/2017/02/28/docker_cmd_analyse5/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<p>所有命令均基于docker1.11版本</p>
<p>上面的分析基本包含了容器相关的大部分命令，剩余一些系统信息、容器底层信息、容器插件或者其他组件相关的命令。<br>但是本章只关注系统信息和容器底层信息相关的命令，其他命令就不做介绍，后续有时间可能会补充。</p>
<h2 id="获取Docker系统相关信息"><a href="#获取Docker系统相关信息" class="headerlink" title="获取Docker系统相关信息"></a>获取Docker系统相关信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: docker info [OPTIONS]</span><br><span class="line"></span><br><span class="line">Display system-wide information</span><br><span class="line"></span><br><span class="line">  --<span class="built_in">help</span>              Print usage</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker -D info</span><br><span class="line">Containers: 14</span><br><span class="line"> Running: 3</span><br><span class="line"> Paused: 1</span><br><span class="line"> Stopped: 10</span><br><span class="line">Images: 52</span><br><span class="line">Server Version: 1.9.0</span><br><span class="line">Storage Driver: aufs</span><br><span class="line"> Root Dir: /var/lib/docker/aufs</span><br><span class="line"> Backing Filesystem: extfs</span><br><span class="line"> Dirs: 545</span><br><span class="line"> Dirperm1 Supported: <span class="literal">true</span></span><br><span class="line">Execution Driver: native-0.2</span><br><span class="line">Logging Driver: json-file</span><br><span class="line">Cgroup Driver: cgroupfs</span><br><span class="line">Plugins:</span><br><span class="line"> Volume: <span class="built_in">local</span></span><br><span class="line"> Network: bridge null host</span><br><span class="line">Kernel Version: 3.19.0-22-generic</span><br><span class="line">OSType: linux</span><br><span class="line">Architecture: x86_64</span><br><span class="line">Operating System: Ubuntu 15.04</span><br><span class="line">CPUs: 24</span><br><span class="line">Total Memory: 62.86 GiB</span><br><span class="line">Name: docker</span><br><span class="line">ID: I54V:OLXT:HVMM:TPKO:JPHQ:CQCD:JNLC:O3BZ:4ZVJ:43XJ:PFHZ:6N2S</span><br><span class="line">Docker Root Dir: /var/lib/docker</span><br><span class="line">Debug mode (client): <span class="literal">true</span></span><br><span class="line">Debug mode (server): <span class="literal">true</span></span><br><span class="line"> File Descriptors: 59</span><br><span class="line"> Goroutines: 159</span><br><span class="line"> System Time: 2015-09-23T14:04:20.699842089+08:00</span><br><span class="line"> EventsListeners: 0</span><br><span class="line"> Init SHA1:</span><br><span class="line"> Init Path: /usr/bin/docker</span><br><span class="line"> Docker Root Dir: /var/lib/docker</span><br><span class="line"> Http Proxy: http://<span class="built_in">test</span>:<span class="built_in">test</span>@localhost:8080</span><br><span class="line"> Https Proxy: https://<span class="built_in">test</span>:<span class="built_in">test</span>@localhost:8080</span><br><span class="line">WARNING: No swap <span class="built_in">limit</span> support</span><br><span class="line">Username: svendowideit</span><br><span class="line">Registry: [https://index.docker.io/v1/]</span><br><span class="line">Labels:</span><br><span class="line"> storage=ssd</span><br></pre></td></tr></table></figure>

<p>这些信息里面，一般比较关注的是Storage和Logging驱动、插件、Registry地址等。<br>注：全局-D可以是docker命令输出调试信息，在发送问题报告的时候，最好带上-D。</p>
<h2 id="容器或镜像的底层信息"><a href="#容器或镜像的底层信息" class="headerlink" title="容器或镜像的底层信息"></a>容器或镜像的底层信息</h2><p>有时可能需要知道容器或者镜像的一些底层信息，可以使用inspect命令获取。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: docker inspect [OPTIONS] CONTAINER|IMAGE [CONTAINER|IMAGE...]</span><br><span class="line"></span><br><span class="line">Return low-level information on a container or image</span><br><span class="line"></span><br><span class="line">  -f, --format=<span class="string">""</span>         Format the output using the given go template</span><br><span class="line">  --<span class="built_in">help</span>                  Print usage</span><br><span class="line">  --<span class="built_in">type</span>=container|image  Return JSON for_specified_type, permissible</span><br><span class="line">                          values are <span class="string">"image"</span> or <span class="string">"container"</span></span><br><span class="line">  -s, --size              Display total file sizes <span class="keyword">if</span> the <span class="built_in">type</span> is container</span><br></pre></td></tr></table></figure>

<p>format命令默认会把结果以JSON格式输出。<br>注意：</p>
<ul>
<li>默认情况下，当容器名和镜像名相同时，format会输容器的结果</li>
<li>当时如果指定了–format，format会返回两个的格式化结果</li>
</ul>
<p>关于–format选项可以参考Go语言的模板，这里只介绍简单的用法，例如获取容器的ID：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect -f=<span class="string">'&#123; &#123;.Id&#125; &#125;'</span> haozi</span><br></pre></td></tr></table></figure>

<h2 id="获取Docker版本信息"><a href="#获取Docker版本信息" class="headerlink" title="获取Docker版本信息"></a>获取Docker版本信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: docker version [OPTIONS]</span><br><span class="line"></span><br><span class="line">Show the Docker version information.</span><br><span class="line"></span><br><span class="line">  -f, --format=<span class="string">""</span>    Format the output using the given go template</span><br><span class="line">  --<span class="built_in">help</span>             Print usage</span><br></pre></td></tr></table></figure>

<p>version命令可以获取Docker版本相关信息，可以用–format来格式化输出，如方法前面。<br>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:        1.11.2</span><br><span class="line"> UnicornVersion: 1.11.2.11.ict</span><br><span class="line"> API version:    1.23</span><br><span class="line"> Go version:     go1.7.4</span><br><span class="line"> Git commit:     008dfcd</span><br><span class="line"> Built:          Tue Feb  7 10:58:04 2017</span><br><span class="line"> OS/Arch:        linux/amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Version:        1.11.2</span><br><span class="line"> UnicornVersion: 1.11.2.11.ict</span><br><span class="line"> API version:    1.23</span><br><span class="line"> Go version:     go1.7.4</span><br><span class="line"> Git commit:     008dfcd</span><br><span class="line"> Built:          Tue Feb  7 10:58:04 2017</span><br><span class="line"> OS/Arch:        linux/amd64</span><br></pre></td></tr></table></figure>

<p>这里比较重要的信息是Docker、API、Go等的版本，例如，Client和Server的版本号不一致可能有各种问题。</p>
]]></content>
      <categories>
        <category>docker</category>
        <category>docker命令</category>
      </categories>
  </entry>
  <entry>
    <title>docker命令分析--维测相关</title>
    <url>/2017/02/28/docker_cmd_analyse4/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<p>所有命令均基于docker1.11版本</p>
<p>这里主要分析容器维测相关的几个命令：</p>
<ul>
<li>stats：获取容器资源使用状态</li>
<li>top：容器内运行进程信息</li>
</ul>
<h2 id="容器资源状态"><a href="#容器资源状态" class="headerlink" title="容器资源状态"></a>容器资源状态</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: docker stats [OPTIONS] [CONTAINER...]</span><br><span class="line"></span><br><span class="line">Display a live stream of one or more containers’ resource usage statistics</span><br><span class="line"></span><br><span class="line">  -a, --all          Show all containers (default shows just running)</span><br><span class="line">  --<span class="built_in">help</span>             Print usage</span><br><span class="line">  --no-stream        Disable streaming stats and only pull the first result</span><br></pre></td></tr></table></figure>

<p>stats命令会返回一个持续的容器资源统计数据流，可以通过指定一些容器ID或者name来限制检测的数量。<br>注：</p>
<ul>
<li>你可以指定一个停止的容器，但是不会返回任何数据。</li>
<li>更详细的统计数据可以通过/containers/(id)/stats API获取</li>
</ul>
<p>例如，获取所有运行的容器资源数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker stats</span><br><span class="line">CONTAINER           CPU %               MEM USAGE / LIMIT     MEM %               NET I/O             BLOCK I/O</span><br><span class="line">1285939c1fd3        0.07%               796 KB / 64 MB        1.21%               788 B / 648 B       3.568 MB / 512 KB</span><br><span class="line">9c76f7834ae2        0.07%               2.746 MB / 64 MB      4.29%               1.266 KB / 648 B    12.4 MB / 0 B</span><br><span class="line">d1ea048f04e4        0.03%               4.583 MB / 64 MB      6.30%               2.854 KB / 648 B    27.7 MB / 0 B</span><br></pre></td></tr></table></figure>

<h2 id="容器内进程信息"><a href="#容器内进程信息" class="headerlink" title="容器内进程信息"></a>容器内进程信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: docker top [OPTIONS] CONTAINER [ps OPTIONS]</span><br><span class="line"></span><br><span class="line">Display the running processes of a container</span><br><span class="line"></span><br><span class="line">  --<span class="built_in">help</span>          Print usage</span><br></pre></td></tr></table></figure>

<p>top命令会显示容器内运行进程的一些信息，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker top hexo</span></span><br><span class="line">UID        PID       PPID      C    STIME      TTY         TIME         CMD</span><br><span class="line">root       3999      3983      0    Feb25      pts/24      00:00:00     /bin/sh -c hexo generate &amp;&amp; hexo server</span><br><span class="line">root       4097      3999      0    Feb25      pts/24      00:12:31     hexo</span><br><span class="line">root       17660     17644     0    Feb27      pts/30      00:00:00     /bin/bash</span><br><span class="line">root       28408     28392     0    Feb27      pts/31      00:00:00     /bin/bash</span><br></pre></td></tr></table></figure>

<p>注意：top只会返回一次结果，和stats的结果不一样。</p>
]]></content>
      <categories>
        <category>docker</category>
        <category>docker命令</category>
      </categories>
  </entry>
  <entry>
    <title>docker命令分析--容器相关</title>
    <url>/2017/02/27/docker_cmd_analyse3/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<p>所有命令均基于docker1.11版本</p>
<p>容器相关的命令，主要包括容器的管理、日志、信息查看以及内容操作。<br>注：由于有些命令比较复杂，限于篇幅可能需要单独开一章，进行详细分析。</p>
<h1 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h1><p>容器的管理涉及容器的整个生命周期：创建、启动、运行、挂起、唤醒、重启、停止、杀死以及删除。本文以容器的生命周期为主线一个个罗列相关命令。</p>
<h2 id="容器的创建"><a href="#容器的创建" class="headerlink" title="容器的创建"></a>容器的创建</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Usage: docker create [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line">Create a new container</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>注意：由于docker create的选项和docker run是一样的，因此这里不详细说明，等到<a href="//2017/02/23/docker_cmd_analyse3/" target="_blank" rel="noopener">docker run</a>分析的时候，再详细分析。<br>create用于创建一个新的容器，主要工作有：</p>
<ul>
<li>在指定镜像之上，创建容器的可写层；</li>
<li>并且准备容器运行指定的命令</li>
<li>输出容器ID到STDOUT</li>
</ul>
<p>“docker create”和”docker run -d”是基本一样的，除了不启动容器外，当然，你可以在任何时候用docker start启动创建的容器。<br>介绍几个简单的使用示例:<br>创建并启动一个可交互的容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker create -t -i fedora bash</span><br><span class="line">6d8af538ec541dd581ebc2a24153a28329acb5268abe5ef868c1f1a261221752</span><br><span class="line">$ docker start -a -i 6d8af538ec5</span><br><span class="line">bash-4.2<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>创建数据卷容器</p>
<p>这是由于v1.4.0后容器的数据卷是在create的阶段进行初始化的，因此create容器数据卷，然后直接在其他容器使用，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker create -v /data --name data ubuntu</span><br><span class="line">240633dfbb98128fa77473d3d9018f6123b99c454b3251427ae190a7d951ad57</span><br><span class="line">$ docker run --rm --volumes-from data ubuntu ls -la /data</span><br><span class="line">total 8</span><br><span class="line">drwxr-xr-x  2 root root 4096 Dec  5 04:10 .</span><br><span class="line">drwxr-xr-x 48 root root 4096 Dec  5 04:11 ..</span><br></pre></td></tr></table></figure>

<p>更详细的分析参考<a href="/2017/02/23/docker_cmd_analyse3/">docker run</a>和<a href="https://docs.docker.com/v1.11/engine/reference/run/" target="_blank" rel="noopener">Docker run refrence</a>。</p>
<h2 id="容器的启动"><a href="#容器的启动" class="headerlink" title="容器的启动"></a>容器的启动</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: docker start [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line">Start one or more containers</span><br><span class="line"></span><br><span class="line">  -a, --attach               Attach STDOUT/STDERR and forward signals</span><br><span class="line">  --detach-keys              Specify the escape key sequence used to detach a container</span><br><span class="line">  --<span class="built_in">help</span>                     Print usage</span><br><span class="line">  -i, --interactive          Attach container STDIN</span><br></pre></td></tr></table></figure>

<p>start命令用于启动一个或者多个容器。start命令的几个参数选项的含义和其他命令的含义是一致的：</p>
<ul>
<li>-a：链接到容器的STDOUT/STDERR，而且可以接收到容器的信号</li>
<li>–detach-keys：这个指定detach的快捷键</li>
<li>-i：表示连接到容器的STDIN，这样才能做一些输入操作，例如敲bash命令</li>
</ul>
<p>注意：这里的-a只是能接收STDOUT/STDERR的数据，如果另外一个shell窗口用docker exec -it连到一个容器，exec里面对容器的操作不会反抗到start -a的窗口。<br>    有点类似于-a是串口，而exec是ssh登录进去的情况。</p>
<h2 id="容器的运行"><a href="#容器的运行" class="headerlink" title="容器的运行"></a>容器的运行</h2><p>run命令可以用于直接运行容器，可以理解为run = create + start，由于这部分内容比较多，<a href="/2017/02/23/docker_cmd_analyse3/">单独用一篇文章描述</a>。</p>
<h2 id="容器的挂起"><a href="#容器的挂起" class="headerlink" title="容器的挂起"></a>容器的挂起</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: docker pause [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line">Pause all processes within a container</span><br><span class="line"></span><br><span class="line">  --<span class="built_in">help</span>          Print usage</span><br></pre></td></tr></table></figure>

<p>pause命令可以暂停一个容器内所有的进程。</p>
<h2 id="容器的唤醒"><a href="#容器的唤醒" class="headerlink" title="容器的唤醒"></a>容器的唤醒</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: docker unpause [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line">Unpause all processes within a container</span><br><span class="line"></span><br><span class="line">  --<span class="built_in">help</span>          Print usage</span><br></pre></td></tr></table></figure>

<p>unpause命令与pause命令相对应，用于唤醒一个容器内所有的进程。</p>
<h2 id="容器的重启"><a href="#容器的重启" class="headerlink" title="容器的重启"></a>容器的重启</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: docker restart [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line">Restart a container</span><br><span class="line"></span><br><span class="line">  --<span class="built_in">help</span>             Print usage</span><br><span class="line">  -t, --time=10      Seconds to <span class="built_in">wait</span>-for-stop before killing the container</span><br></pre></td></tr></table></figure>

<p>restart命令用于重启一个容器，可以用-t设置等待容器停止的时间，超时则杀死容器。</p>
<h2 id="容器的停止"><a href="#容器的停止" class="headerlink" title="容器的停止"></a>容器的停止</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: docker stop [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line">Stop a container by sending SIGTERM and <span class="keyword">then</span> SIGKILL after a</span><br><span class="line">grace period</span><br><span class="line"></span><br><span class="line">  --<span class="built_in">help</span>             Print usage</span><br><span class="line">  -t, --time=10      Seconds to <span class="built_in">wait</span>-for-stop before killing it</span><br></pre></td></tr></table></figure>

<p>stop命令可以通过发送SIGTERM以及合理间隔后发送的SIGKILL来停止一个容器，-t选项和restart的用法一致。<br>注：只有容器的主进程才会收到SIGTERM信号，并且在合理间隔之后收到SIGKILL信号。</p>
<h2 id="容器的杀死"><a href="#容器的杀死" class="headerlink" title="容器的杀死"></a>容器的杀死</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: docker <span class="built_in">kill</span> [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line">Kill a running container using SIGKILL or a specified signal</span><br><span class="line"></span><br><span class="line">  --<span class="built_in">help</span>                 Print usage</span><br><span class="line">  -s, --signal=<span class="string">"KILL"</span>    Signal to send to the container</span><br></pre></td></tr></table></figure>

<p>kill命令通过SIGKILL或者其他指定信号来杀死一个运行中的容器，-s选项可以指定一个发送给容器的信号。<br>和stop一样，主进程会收到信号。</p>
<p>注意：如果ENTRYPOINT和CMD是以shell格式运行的，那么他们是不会收到信号的。这是由于这种情况下bash才是主进程,<br>    只有PID为1的进程能收到。关于ENTRYPOINT和CMD可以参考<a href="https://docs.docker.com/v1.11/engine/reference/builder/#entrypoint" target="_blank" rel="noopener">官方文档</a></p>
<h2 id="容器的删除"><a href="#容器的删除" class="headerlink" title="容器的删除"></a>容器的删除</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: docker rm [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line">Remove one or more containers</span><br><span class="line"></span><br><span class="line">  -f, --force            Force the removal of a running container (uses SIGKILL)</span><br><span class="line">  --<span class="built_in">help</span>                 Print usage</span><br><span class="line">  -l, --link             Remove the specified link</span><br><span class="line">  -v, --volumes          Remove the volumes associated with the container</span><br></pre></td></tr></table></figure>

<p>rm可以删除一个或者多个容器。<br>可以通过指定–force选项，通过发送SIGKILL信号强制删除一个运行的容器，例如：docker rm –force redis<br>可以通过–link删除默认网桥上指定的link，删除所有的网络配置，例如：docker rm –link /webapp/redis<br>注意：–link不能删除用户指定的网络，只能删除默认网桥上的link。<br>可以通过–volumes删除容器关联的数据卷，这里需要注意下面的情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker create -v awesome:/foo -v /bar --name hello redis</span><br><span class="line">hello</span><br><span class="line">$ docker rm -v hello</span><br></pre></td></tr></table></figure>
<p>这里只会删除/bar数据卷，/foo数据卷不会被删除，是由于/foo关联到host的文件或者目录awesome。</p>
<p>删除所有停止的容器：docker rm $(docker ps -a -q)</p>
<h2 id="容器的重命名"><a href="#容器的重命名" class="headerlink" title="容器的重命名"></a>容器的重命名</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: docker rename [OPTIONS] OLD_NAME NEW_NAME</span><br><span class="line"></span><br><span class="line">Rename a container</span><br><span class="line"></span><br><span class="line">  --<span class="built_in">help</span>          Print usage</span><br></pre></td></tr></table></figure>

<p>rename命令可以用于重命名容器。<br>注意：如果你启动的时候没有指定容器的名字，docker会生成一个，但是你也可以用容器的ID作为OLD_NAME来重命名该容器。<br>例如：docker rename b8929ca5eda3 haozi</p>
<h2 id="容器的更新"><a href="#容器的更新" class="headerlink" title="容器的更新"></a>容器的更新</h2><p>update命令用于更新容器的一些配置，详细可以参考<a href="/2017/01/19/docker_update_cmd/">update命令分析</a></p>
<p>关于容器生命周期相关的命令，就结束了。下面看看其他和容器相关的一些常用的命令。</p>
<h2 id="attach和exec命令"><a href="#attach和exec命令" class="headerlink" title="attach和exec命令"></a>attach和exec命令</h2><p>首先，attach可以挂到一个运行的容器上，而exec可以在容器内执行指定的命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: docker attach [OPTIONS] CONTAINER</span><br><span class="line"></span><br><span class="line">Attach to a running container</span><br><span class="line"></span><br><span class="line">  --detach-keys=<span class="string">"&lt;sequence&gt;"</span>       Set up escape key sequence</span><br><span class="line">  --<span class="built_in">help</span>                           Print usage</span><br><span class="line">  --no-stdin                       Do not attach STDIN</span><br><span class="line">  --sig-proxy=<span class="literal">true</span>                 Proxy all received signals to the process</span><br></pre></td></tr></table></figure>

<p>attach命令可以挂到一个运行中的容器上，然后你可以看到该容器正在输出的内容，或者以交互的方式控制它。</p>
<p>停止一个容器默认使用Ctrl-c，这个组合键会发送一个SIGKILL信号给容器。但是–sig-proxy=true被设置的话，<br>Ctrl-c会发送SIGINT给容器。可以通过Ctrl+p，Ctrl+q端口连接并保持容器运行。</p>
<p>注意：通过attach连接到容器的stdio，Docker提供1MB的缓存接收应用的输出，如果buffer满了，会影响attach的输出速度。</p>
<p>然后，exec可以在运行的容器中运行一条命令。当容器运行的第一条命令不是bash或者没有指定-it的时候，用attach连到容器是不能做一些输入或者指令操作的。<br>但是我们可以用exec在容器内运行bash或者其他指令来达到操作容器的目的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: docker <span class="built_in">exec</span> [OPTIONS] CONTAINER COMMAND [ARG...]</span><br><span class="line"></span><br><span class="line">Run a <span class="built_in">command</span> <span class="keyword">in</span> a running container</span><br><span class="line"></span><br><span class="line">  -d, --detach               Detached mode: run <span class="built_in">command</span> <span class="keyword">in</span> the background</span><br><span class="line">  --detach-keys              Specify the escape key sequence used to detach a container</span><br><span class="line">  --<span class="built_in">help</span>                     Print usage</span><br><span class="line">  -i, --interactive          Keep STDIN open even <span class="keyword">if</span> not attached</span><br><span class="line">  --privileged               Give extended Linux capabilities to the <span class="built_in">command</span></span><br><span class="line">  -t, --tty                  Allocate a pseudo-TTY</span><br><span class="line">  -u, --user=                Username or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;])</span><br></pre></td></tr></table></figure>

<p>注：exec只有在容器的第一个进程在运行时，才能执行。如果容器是pause状态，exec会返回失败。<br>各选项作用：</p>
<ul>
<li>–detach：后台执行命令</li>
<li>–detach-keys：指定断开连接的快捷键</li>
<li>–interactive：支持输入</li>
<li>–privileged：设置运行命令在特权模式下运行</li>
<li>–tty：分配一个伪终端</li>
<li>–user：设置执行命令用户名</li>
</ul>
<h2 id="容器的日志"><a href="#容器的日志" class="headerlink" title="容器的日志"></a>容器的日志</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: docker logs [OPTIONS] CONTAINER</span><br><span class="line"></span><br><span class="line">Fetch the logs of a container</span><br><span class="line"></span><br><span class="line">  -f, --follow              Follow <span class="built_in">log</span> output</span><br><span class="line">  --<span class="built_in">help</span>                    Print usage</span><br><span class="line">  --since=<span class="string">""</span>                Show logs since timestamp</span><br><span class="line">  -t, --timestamps          Show timestamps</span><br><span class="line">  --tail=<span class="string">"all"</span>              Number of lines to show from the end of the logs</span><br></pre></td></tr></table></figure>

<p>logs命令可以获取容器的日志信息。logs的日志信息保存位置取决于<a href="/2016/12/29/docker_container_log/">日志的驱动</a>，<br>默认容器日志的驱动为json，数据保存在/var/lib/docker/containers/container-ID/container-ID-json.log文件。<br>日志驱动可以通过docker run和docker daemon的–log-driver选项设置。</p>
<p>logs命令的选项作用：</p>
<ul>
<li>–follow：命令可以持续获取容器的STDOUT和STDERR的信息。</li>
<li>–since：命令值显示指定时间戳之后的日志</li>
<li>–timestamps：命令在每条日志之前加上时间戳</li>
<li>–tail：命令只显示日志最后的指定行数</li>
</ul>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>docker命令</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown文件格式导致hexo generate失败</title>
    <url>/2017/02/25/hexo_generate_err1/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<h2 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INFO  Start processing</span><br><span class="line">FATAL Something<span class="string">'s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span></span><br><span class="line"><span class="string">Template render error: (unknown path) [Line 191, Column 51]</span></span><br><span class="line"><span class="string">  unexpected token: .</span></span><br><span class="line"><span class="string">    at Object.exports.prettifyError (/blog/node_modules/nunjucks/src/lib.js:34:15)</span></span><br><span class="line"><span class="string">    at new_cls.render (/blog/node_modules/nunjucks/src/environment.js:469:27)</span></span><br><span class="line"><span class="string">    at new_cls.renderString (/blog/node_modules/nunjucks/src/environment.js:327:21)</span></span><br><span class="line"><span class="string">    at /blog/node_modules/hexo/lib/extend/tag.js:66:9</span></span><br><span class="line"><span class="string">    at Promise._execute (/blog/node_modules/bluebird/js/release/debuggability.js:299:9)</span></span><br><span class="line"><span class="string">    at Promise._resolveFromExecutor (/blog/node_modules/bluebird/js/release/promise.js:481:18)</span></span><br><span class="line"><span class="string">    at new Promise (/blog/node_modules/bluebird/js/release/promise.js:77:14)</span></span><br><span class="line"><span class="string">    at Tag.render (/blog/node_modules/hexo/lib/extend/tag.js:64:10)</span></span><br><span class="line"><span class="string">    at Object.tagFilter [as onRenderEnd] (/blog/node_modules/hexo/lib/hexo/post.js:253:16)</span></span><br><span class="line"><span class="string">    at /blog/node_modules/hexo/lib/hexo/render.js:65:19</span></span><br><span class="line"><span class="string">    at tryCatcher (/blog/node_modules/bluebird/js/release/util.js:16:23)</span></span><br><span class="line"><span class="string">    at Promise._settlePromiseFromHandler (/blog/node_modules/bluebird/js/release/promise.js:510:31)</span></span><br><span class="line"><span class="string">    at Promise._settlePromise (/blog/node_modules/bluebird/js/release/promise.js:567:18)</span></span><br><span class="line"><span class="string">    at Promise._settlePromise0 (/blog/node_modules/bluebird/js/release/promise.js</span></span><br><span class="line"><span class="string">FROM node</span></span><br><span class="line"><span class="string">:612:10)</span></span><br><span class="line"><span class="string">    at Promise._settlePromises (/blog/node_modules/bluebird/js/release/promise.js:691:18)</span></span><br><span class="line"><span class="string">    at Async._drainQueue (/blog/node_modules/bluebird/js/release/async.js:138:16)</span></span><br><span class="line"><span class="string">    at Async._drainQueues (/blog/node_modules/bluebird/js/release/async.js:148:10)</span></span><br><span class="line"><span class="string">    at Immediate.Async.drainQueues (/blog/node_modules/bluebird/js/release/async.js:17:14)</span></span><br><span class="line"><span class="string">    at runCallback (timers.js:649:20)</span></span><br><span class="line"><span class="string">    at tryOnImmediate (timers.js:622:5)</span></span><br><span class="line"><span class="string">    at processImmediate [as _immediateCallback] (timers.js:594:5)</span></span><br><span class="line"><span class="string">FATAL (unknown path) [Line 191, Column 51]</span></span><br><span class="line"><span class="string">  unexpected token: .</span></span><br><span class="line"><span class="string">Template render error: (unknown path) [Line 191, Column 51]</span></span><br><span class="line"><span class="string">  unexpected token: .</span></span><br><span class="line"><span class="string">    at Object.exports.prettifyError (/blog/node_modules/nunjucks/src/lib.js:34:15)</span></span><br><span class="line"><span class="string">    at new_cls.render (/blog/node_modules/nunjucks/src/environment.js:469:27)</span></span><br><span class="line"><span class="string">    at new_cls.renderString (/blog/node_modules/nunjucks/src/environment.js:327:21)</span></span><br><span class="line"><span class="string">    at /blog/node_modules/hexo/lib/extend/tag.js:66:9</span></span><br><span class="line"><span class="string">    at Promise._execute (/blog/node_modules/bluebird/js/release/debuggability.js:299:9)</span></span><br><span class="line"><span class="string">    at Promise._resolveFromExecutor (/blog/node_modules/bluebird/js/release/promise.js:481:18)</span></span><br><span class="line"><span class="string">    at new Promise (/blog/node_modules/bluebird/js/release/promise.js:77:14)</span></span><br><span class="line"><span class="string">    at Tag.render (/blog/node_modules/hexo/lib/extend/tag.js:64:10)</span></span><br><span class="line"><span class="string">    at Object.tagFilter [as onRenderEnd] (/blog/node_modules/hexo/lib/hexo/post.js:253:16)</span></span><br><span class="line"><span class="string">    at /blog/node_modules/hexo/lib/hexo/render.js:65:19</span></span><br><span class="line"><span class="string">    at tryCatcher (/blog/node_modules/bluebird/js/release/util.js:16:23)</span></span><br><span class="line"><span class="string">    at Promise._settlePromiseFromHandler (/blog/node_modules/bluebird/js/release/promise.js:510:31)</span></span><br><span class="line"><span class="string">    at Promise._settlePromise (/blog/node_modules/bluebird/js/release/promise.js:567:18)</span></span><br><span class="line"><span class="string">    at Promise._settlePromise0 (/blog/node_modules/bluebird/js/release/promise.js:612:10)</span></span><br><span class="line"><span class="string">    at Promise._settlePromises (/blog/node_modules/bluebird/js/release/promise.js:691:18)</span></span><br><span class="line"><span class="string">    at Async._drainQueue (/blog/node_modules/bluebird/js/release/async.js:138:16)</span></span><br><span class="line"><span class="string">    at Async._drainQueues (/blog/node_modules/bluebird/js/release/async.js:148:10)</span></span><br><span class="line"><span class="string">    at Immediate.Async.drainQueues (/blog/node_modules/bluebird/js/release/async.js:17:14)</span></span><br><span class="line"><span class="string">    at runCallback (timers.js:649:20)</span></span><br><span class="line"><span class="string">    at tryOnImmediate (timers.js:622:5)</span></span><br><span class="line"><span class="string">    at processImmediate [as _immediateCallback] (timers.js:594:5)</span></span><br></pre></td></tr></table></figure>

<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>由于markdown文件中包含了“{ { *** } }”（注意括号之间没有空格），可以在“{加一个空格{”。</p>
]]></content>
      <categories>
        <category>hexo</category>
        <category>hexo错误</category>
      </categories>
  </entry>
  <entry>
    <title>docker命令分析--镜像相关</title>
    <url>/2017/02/23/docker_cmd_analyse2/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<p>所有命令均基于docker1.11版本</p>
<p>镜像相关的命令主要包括三类：</p>
<ul>
<li>镜像registry相关命令</li>
<li>镜像构建相关命令</li>
<li>镜像操作相关命令</li>
</ul>
<h2 id="镜像registry操作"><a href="#镜像registry操作" class="headerlink" title="镜像registry操作"></a>镜像registry操作</h2><p>在使用docker的过程中，可能需要从镜像registry获取镜像，或者把自己构建的镜像保存到registry。<br>包括下面几个命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">login     Log <span class="keyword">in</span> to a Docker registry</span><br><span class="line"><span class="built_in">logout</span>    Log out from a Docker registry</span><br><span class="line">pull      Pull an image or a repository from a registry</span><br><span class="line">push      Push an image or a repository to a registry</span><br><span class="line">search    Search the Docker Hub <span class="keyword">for</span> images</span><br><span class="line">tag       Tag an image into a repository</span><br></pre></td></tr></table></figure>

<h3 id="login和logout"><a href="#login和logout" class="headerlink" title="login和logout"></a>login和logout</h3><p>这两个命令主要是用于登录和退出Docker registry的，比较简单，这里只给出基本用法。</p>
<ol>
<li>login命令</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: docker login [OPTIONS] [SERVER]</span><br><span class="line"></span><br><span class="line">Log <span class="keyword">in</span> to a Docker registry server, <span class="keyword">if</span> no server is</span><br><span class="line">specified <span class="string">"https://index.docker.io/v1/"</span> is the default.</span><br><span class="line"></span><br><span class="line">  --<span class="built_in">help</span>               Print usage</span><br><span class="line">  -p, --password=<span class="string">""</span>    Password</span><br><span class="line">  -u, --username=<span class="string">""</span>    Username</span><br></pre></td></tr></table></figure>

<p>如果没有指定服务器地址，默认服务器地址为：<a href="https://index.docker.io/v1/。服务器地址可以是自己搭建的本地仓库。" target="_blank" rel="noopener">https://index.docker.io/v1/。服务器地址可以是自己搭建的本地仓库。</a></p>
<ol start="2">
<li>logout命令</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: docker <span class="built_in">logout</span> [SERVER]</span><br><span class="line"></span><br><span class="line">Log out from a Docker registry, <span class="keyword">if</span> no server is</span><br><span class="line">specified <span class="string">"https://index.docker.io/v1/"</span> is the default.</span><br><span class="line"></span><br><span class="line">  --<span class="built_in">help</span>          Print usage</span><br></pre></td></tr></table></figure>

<h3 id="pull、push和search"><a href="#pull、push和search" class="headerlink" title="pull、push和search"></a>pull、push和search</h3><ol>
<li>pull命令：用于从registry下拉镜像或者</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: docker pull [OPTIONS] NAME[:TAG] | [REGISTRY_HOST[:REGISTRY_PORT]/]NAME[:TAG]</span><br><span class="line"></span><br><span class="line">Pull an image or a repository from the registry</span><br><span class="line"></span><br><span class="line">  -a, --all-tags                Download all tagged images <span class="keyword">in</span> the repository</span><br><span class="line">  --<span class="built_in">disable</span>-content-trust=<span class="literal">true</span>  Skip image verification</span><br><span class="line">  --<span class="built_in">help</span>                        Print usage</span><br></pre></td></tr></table></figure>
<p>注：如果是在内网，需要配置代理，可以参考上篇文章。</p>
<p>用pull下载单个镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获取默认debian:latest</span></span><br><span class="line">$ docker pull debian</span><br><span class="line"><span class="comment">#指定debian的tag</span></span><br><span class="line">$ docker pull debian:jessie</span><br></pre></td></tr></table></figure>

<p>上面的pull镜像的方式，可以保证你获取的镜像永远是最新的版本的。但是，如果你想获取某个特定版本的，可以通过digest的方式获取。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull ubuntu:14.04</span><br><span class="line"></span><br><span class="line">14.04: Pulling from library/ubuntu</span><br><span class="line">5a132a7e7af1: Pull complete</span><br><span class="line">fd2731e4c50c: Pull complete</span><br><span class="line">28a2f68d1120: Pull complete</span><br><span class="line">a3ed95caeb02: Pull complete</span><br><span class="line">Digest: sha256:45b23dee08af5e43a7fea6c4cf9c25ccf269ee113168c19722f87876677c5cb2</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> ubuntu:14.04</span><br></pre></td></tr></table></figure>
<p>上面的镜像会包含一个Digest信息：sha256:45b23dee08af5e43a7fea6c4cf9c25ccf269ee113168c19722f87876677c5cb2<br>为了获取固定版本的镜像，可以通过下面的方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull ubuntu@sha256:45b23dee08af5e43a7fea6c4cf9c25ccf269ee113168c19722f87876677c5cb2</span><br></pre></td></tr></table></figure>

<p>从其他registry获取镜像或者仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull myregistry.local:5000/testing/<span class="built_in">test</span>-image</span><br></pre></td></tr></table></figure>
<p>注：</p>
<ul>
<li>docker pull默认从Docker hub上面下拉镜像。</li>
<li>myregistry是否是支持insecure方式，如果不支持可能需要一些配置才能pull成功</li>
</ul>
<p>获取一个仓库的所有镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull --all-tags fedora</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>push命令：往registry推送镜像或者仓库</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: docker push [OPTIONS] NAME[:TAG]</span><br><span class="line"></span><br><span class="line">Push an image or a repository to the registry</span><br><span class="line"></span><br><span class="line">  --<span class="built_in">disable</span>-content-trust=<span class="literal">true</span>   Skip image signing</span><br><span class="line">  --<span class="built_in">help</span>                         Print usage</span><br></pre></td></tr></table></figure>

<p>注：</p>
<ul>
<li>默认推送到Docker hub，可以推送的自己构建的registry。</li>
<li>–disable-content-trust=true可以跳过镜像签名</li>
</ul>
<ol start="3">
<li>search命令：在Docker hub搜索镜像</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: docker search [OPTIONS] TERM</span><br><span class="line"></span><br><span class="line">Search the Docker Hub <span class="keyword">for</span> images</span><br><span class="line"></span><br><span class="line">  --automated          Only show automated builds</span><br><span class="line">  --<span class="built_in">help</span>               Print usage</span><br><span class="line">  --no-trunc           Don<span class="string">'t truncate output</span></span><br><span class="line"><span class="string">  -s, --stars=0        Only displays with at least x stars</span></span><br></pre></td></tr></table></figure>
<p>注意：search的说明是在Docker hub上搜索，其实也可以用来搜索自己搭建的registry，但是，如果用registry容器镜像搭建的registry是没有打开search模块的。<br>    因此，search功能在这样的registry上面是不能工作的。</p>
<p>通过镜像名搜索</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker search ubuntu</span><br></pre></td></tr></table></figure>

<p>通过镜像名和stars次数搜索</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker search --stars=3 busybox</span><br><span class="line">NAME                 DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">busybox              Busybox base image.                             325       [OK]       </span><br><span class="line">progrium/busybox                                                     50                   [OK]</span><br><span class="line">radial/busyboxplus   Full-chain, Internet enabled, busybox made...   8                    [OK]</span><br></pre></td></tr></table></figure>
<p>这里stars表示该镜像在Docker Hub上被人关注的次数。</p>
<p>查询自动构建的镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker search --stars=3 --automated busybox</span><br><span class="line">NAME                 DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">progrium/busybox                                                     50                   [OK]</span><br><span class="line">radial/busyboxplus   Full-chain, Internet enabled, busybox made...   8                    [OK]</span><br></pre></td></tr></table></figure>
<p>automated感觉用来标识非官方镜像</p>
<p>查询未截断描述的镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker search --stars=3 --no-trunc busybox</span><br><span class="line">NAME                 DESCRIPTION                                                                               STARS     OFFICIAL   AUTOMATED</span><br><span class="line">busybox              Busybox base image.                                                                       325       [OK]       </span><br><span class="line">progrium/busybox                                                                                               50                   [OK]</span><br><span class="line">radial/busyboxplus   Full-chain, Internet enabled, busybox made from scratch. Comes <span class="keyword">in</span> git and cURL flavors.   8                    [OK]</span><br></pre></td></tr></table></figure>

<h3 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h3><p>tag命令用于修改镜像的仓库名和tag</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]</span><br><span class="line"></span><br><span class="line">Tag an image into a repository</span><br><span class="line"></span><br><span class="line">  --<span class="built_in">help</span>               Print usage</span><br></pre></td></tr></table></figure>

<p>注：如果需要把镜像push到一个自定的registry，首先需要就是tag镜像到该registry的一个仓库（参考文章：搭建本地的Docker registry）。</p>
]]></content>
      <categories>
        <category>docker</category>
        <category>docker命令</category>
      </categories>
  </entry>
  <entry>
    <title>docker命令分析--镜像相关2</title>
    <url>/2017/02/23/docker_cmd_analyse2_2/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<p>所有命令均基于docker1.11版本</p>
<h2 id="镜像构建"><a href="#镜像构建" class="headerlink" title="镜像构建"></a>镜像构建</h2><p>这部分主要包含，镜像制作相关的命令分析。镜像制作有三种情况：</p>
<ul>
<li>从零开始，基于rootfs制作</li>
<li>基于已有镜像，用Dockerfile制作</li>
<li>保存运行容器为镜像</li>
</ul>
<p>对应的三个命令如下：</p>
<ul>
<li>import    导入tar包内容，创建一个文件系统镜像</li>
<li>build     基于Dockerfile构建镜像</li>
<li>commit    把容器的修改制作为一个新的镜像</li>
</ul>
<h3 id="import命令"><a href="#import命令" class="headerlink" title="import命令"></a>import命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: docker import file|URL|- [REPOSITORY[:TAG]]</span><br><span class="line"></span><br><span class="line">Create an empty filesystem image and import the contents of the</span><br><span class="line">tarball (.tar, .tar.gz, .tgz, .bzip, .tar.xz, .txz) into it, <span class="keyword">then</span></span><br><span class="line">optionally tag it.</span><br><span class="line"></span><br><span class="line">  -c, --change=[]     Apply specified Dockerfile instructions <span class="keyword">while</span> importing the image</span><br><span class="line">  --<span class="built_in">help</span>              Print usage</span><br><span class="line">  -m, --message=      Set commit message <span class="keyword">for</span> imported image</span><br></pre></td></tr></table></figure>

<p>注意：import是会先创建一个空的文件系统镜像，然后把tar包的内容导入。这和后面提到的load命令的操作是不一样的。</p>
<p>import支持三种读取文件方式：</p>
<ul>
<li>直接指定本地路径，例如：docker import /path/to/exampleimage.tgz</li>
<li>指定远程URL，例如：docker import <a href="http://example.com/exampleimage.tgz" target="_blank" rel="noopener">http://example.com/exampleimage.tgz</a></li>
<li>通过STDIN，分两种情况，一个是tar包文件，例如：cat exampleimage.tgz | docker import - exampleimagelocal:new ；一个是目录，例如：tar -c . | docker import - exampleimagedir</li>
</ul>
<p>import的-c选项在已创建的镜像上用Dockerfile的指令对镜像做修改，目前支持的指令有：CMD|ENTRYPOINT|ENV|EXPOSE|ONBUILD|USER|VOLUME|WORKDIR。<br>例如，给新制作的镜像增加一个DEBUG的环境变量：tar -c . | docker import –change “ENV DEBUG true” - exampleimagedir</p>
<h3 id="build命令"><a href="#build命令" class="headerlink" title="build命令"></a>build命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: docker build [OPTIONS] PATH | URL | -</span><br><span class="line"></span><br><span class="line">Build a new image from the <span class="built_in">source</span> code at PATH</span><br><span class="line"></span><br><span class="line">  --build-arg=[]                  Set build-time variables</span><br><span class="line">  --cpu-shares                    CPU Shares (relative weight)</span><br><span class="line">  --cgroup-parent=<span class="string">""</span>              Optional parent cgroup <span class="keyword">for</span> the container</span><br><span class="line">  --cpu-period=0                  Limit the CPU CFS (Completely Fair Scheduler) period</span><br><span class="line">  --cpu-quota=0                   Limit the CPU CFS (Completely Fair Scheduler) quota</span><br><span class="line">  --cpuset-cpus=<span class="string">""</span>                CPUs <span class="keyword">in</span> <span class="built_in">which</span> to allow execution, e.g. `0-3`, `0,1`</span><br><span class="line">  --cpuset-mems=<span class="string">""</span>                MEMs <span class="keyword">in</span> <span class="built_in">which</span> to allow execution, e.g. `0-3`, `0,1`</span><br><span class="line">  --<span class="built_in">disable</span>-content-trust=<span class="literal">true</span>    Skip image verification</span><br><span class="line">  -f, --file=<span class="string">""</span>                   Name of the Dockerfile (Default is <span class="string">'PATH/Dockerfile'</span>)</span><br><span class="line">  --force-rm                      Always remove intermediate containers</span><br><span class="line">  --<span class="built_in">help</span>                          Print usage</span><br><span class="line">  --isolation=<span class="string">""</span>                  Container isolation technology</span><br><span class="line">  --label=[]                      Set metadata <span class="keyword">for</span> an image</span><br><span class="line">  -m, --memory=<span class="string">""</span>                 Memory <span class="built_in">limit</span> <span class="keyword">for</span> all build containers</span><br><span class="line">  --memory-swap=<span class="string">""</span>                A positive <span class="built_in">integer</span> equal to memory plus swap. Specify -1 to <span class="built_in">enable</span> unlimited swap.</span><br><span class="line">  --no-cache                      Do not use cache when building the image</span><br><span class="line">  --pull                          Always attempt to pull a newer version of the image</span><br><span class="line">  -q, --quiet                     Suppress the build output and <span class="built_in">print</span> image ID on success</span><br><span class="line">  --rm=<span class="literal">true</span>                       Remove intermediate containers after a successful build</span><br><span class="line">  --shm-size=[]                   Size of `/dev/shm`. The format is `&lt;number&gt;&lt;unit&gt;`. `number` must be greater than `0`.  Unit is optional and can be `b` (bytes), `k` (kilobytes), `m` (megabytes), or `g` (gigabytes). If you omit the unit, the system uses bytes. If you omit the size entirely, the system uses `64m`.</span><br><span class="line">  -t, --tag=[]                    Name and optionally a tag <span class="keyword">in</span> the <span class="string">'name:tag'</span> format</span><br><span class="line">  --<span class="built_in">ulimit</span>=[]                     Ulimit options</span><br></pre></td></tr></table></figure>

<p>build是根据Dockerfile和上下文构建Docker镜像，这里的上下文是PATH或者URL所指目录的文件。Dockerfile获取方式也是三种：</p>
<ul>
<li>直接指定本地路径，例如以当前目录的Dockerfile和文件上下文构建：docker build .</li>
<li>指定远程URL，例如从github下载：docker build github.com/creack/docker-firefox</li>
<li>通过STDIN，两种情况，一个是不包含上下文：docker build - &lt; Dockerfile；一个是带上下文docker build - &lt; context.tar.gz</li>
</ul>
<p>关于build命令的选项，这里就描述几个常用的，其他的可以参考官方文档。</p>
<p>-t：用于指定构建的镜像的repository名和tag，值的格式为“name:tag”，例如：docker build -t vieux/apache:2.0 .<br>    也可以给一个镜像指定多个tag，例如：docker build -t whenry/fedora-jboss:latest -t whenry/fedora-jboss:v2.1 .<br>-f：指定Dockerfile文件路径，默认的Dockerfile名就是Dockerfile，build命令的上下文路径里面必须有Dockerfile文件，<br>    但是可以通过-f来指定其他名字的Dockerfile文件，例如：docker build -f Dockerfile.debug .<br>–build-arg：设置build过程中的参数，该参数的有效期为build过程，例如设置HTTP_PROXY环境变量：docker build –build-arg HTTP_PROXY=<a href="http://10.20.30.2:1234" target="_blank" rel="noopener">http://10.20.30.2:1234</a> .</p>
<h3 id="commit命令"><a href="#commit命令" class="headerlink" title="commit命令"></a>commit命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br><span class="line"></span><br><span class="line">Create a new image from a container<span class="string">'s changes</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  -a, --author=""     Author (e.g., "John Hannibal Smith &lt;hannibal@a-team.com&gt;")</span></span><br><span class="line"><span class="string">  -c, --change=[]     Apply specified Dockerfile instructions while committing the image</span></span><br><span class="line"><span class="string">  --help              Print usage</span></span><br><span class="line"><span class="string">  -m, --message=""    Commit message</span></span><br><span class="line"><span class="string">  -p, --pause=true    Pause container during commit</span></span><br></pre></td></tr></table></figure>

<p>commit以运行的容器构建Docker镜像，可以在命令最后面直接指定新构建的镜像repository和tag。<br>commit命令可以方便的保存当前容器的状态到镜像中，然后可以方便的迁移到另外一台机器中继续运行，用于测试或者调试是很好的方法。不过，管理镜像还是用Dockerfile更合理。</p>
<p>commit命令的选项比较简单，主要包括：</p>
<ul>
<li>-a 设置镜像的作者</li>
<li>-c 和import命令一样</li>
<li>-m 设置commit的信息</li>
<li>-p 可以设置构建镜像过程中，是否停止容器中进程运行，默认情况下是停止容器中的进程。</li>
</ul>
<h2 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h2><p>镜像操作主要是镜像的导入、导出、删除、查看镜像列表以及查看镜像的历史信息，对应命令如下：</p>
<ul>
<li>load/save</li>
<li>import/export</li>
<li>images</li>
<li>rmi</li>
<li>history</li>
</ul>
<h3 id="导入导出"><a href="#导入导出" class="headerlink" title="导入导出"></a>导入导出</h3><p>镜像的导入导出有两组命令，分别是import/export和load/save。</p>
<ol>
<li>导入</li>
</ol>
<p>import可以参考上文。<br>load命令：只是从tar包或者STDIN中加载镜像。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: docker load [OPTIONS]</span><br><span class="line"></span><br><span class="line">Load an image from a tar archive or STDIN</span><br><span class="line"></span><br><span class="line">  --<span class="built_in">help</span>             Print usage</span><br><span class="line">  -i, --input=<span class="string">""</span>     Read from a tar archive file, instead of STDIN. The tarball may be compressed with gzip, bzip, or xz</span><br><span class="line">  -q, --quiet        Suppress the load output. Without this option, a progress bar is displayed.</span><br></pre></td></tr></table></figure>

<p>import和load的区别在于：</p>
<ul>
<li>import会创建一个空的文件系统镜像，然后才会把tar包或者STDIN中的内容导入到空的镜像中。（会从零开始创建一个镜像）</li>
<li>load只是把tar包或者STDIN中的镜像导入，这说明tar包或者STDIN中的输入本身就是一个镜像。（简单的导入已有镜像）</li>
</ul>
<ol start="2">
<li>导出</li>
</ol>
<p>export命令：导出容器的文件系统到tar文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: docker <span class="built_in">export</span> [OPTIONS] CONTAINER</span><br><span class="line"></span><br><span class="line">Export the contents of a container<span class="string">'s filesystem as a tar archive</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  --help             Print usage</span></span><br><span class="line"><span class="string">  -o, --output=""    Write to a file, instead of STDOUT</span></span><br></pre></td></tr></table></figure>

<p>两种用法：</p>
<ul>
<li>docker export hexo &gt; myhexo.tar</li>
<li>docker export –output=”myhexo.tar” hexo</li>
</ul>
<p>注： export不导出数据卷的内容</p>
<p>save命令：把一个或者多个镜像导出到tar文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: docker save [OPTIONS] IMAGE [IMAGE...]</span><br><span class="line"></span><br><span class="line">Save one or more images to a tar archive (streamed to STDOUT by default)</span><br><span class="line"></span><br><span class="line">  --<span class="built_in">help</span>             Print usage</span><br><span class="line">  -o, --output=<span class="string">""</span>    Write to a file, instead of STDOUT</span><br></pre></td></tr></table></figure>

<p>注：save会把所有父层以及name:tag导出，除非重名name:tag。<br>几种用法：</p>
<ul>
<li>使用标准输出导出一个镜像： docker save busybox &gt; busybox.tar</li>
<li>指定输出流导出一个镜像：docker save –output busybox.tar busybox</li>
<li>导出整个repository：docker save -o fedora-all.tar fedora</li>
</ul>
<p>export和save都是导出容器镜像，区别在：</p>
<ul>
<li>export是导出容器的文件系统</li>
<li>save是保存加载的容器镜像</li>
</ul>
<h3 id="查看镜像列表"><a href="#查看镜像列表" class="headerlink" title="查看镜像列表"></a>查看镜像列表</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage:	docker images [OPTIONS] [REPOSITORY[:TAG]]</span><br><span class="line"></span><br><span class="line">List images</span><br><span class="line"></span><br><span class="line">  -a, --all          Show all images (default hides intermediate images)</span><br><span class="line">  --digests          Show digests</span><br><span class="line">  -f, --filter=[]    Filter output based on conditions provided</span><br><span class="line">  --format           Pretty-print images using a Go template</span><br><span class="line">  --<span class="built_in">help</span>             Print usage</span><br><span class="line">  --no-trunc         Don<span class="string">'t truncate output</span></span><br><span class="line"><span class="string">  -q, --quiet        Only show numeric IDs</span></span><br></pre></td></tr></table></figure>

<p>history用于列出镜像列表，主要用法如下：</p>
<ul>
<li>默认显示顶层的镜像、它们的repository名、tag以及镜像大小（如果镜像ID一样而且有多个tag或者repository，则会列出多次）：docker images</li>
<li>以repository名列出镜像列表（repository名必须完全匹配）：docker images java</li>
<li>以repository名和tag列出镜像列表（必须完全匹配）：docker images java:8</li>
<li>显示镜像的完整ID：docker images –no-trunc</li>
<li>以摘要列出镜像列表（只有v2以上版本的镜像才有digest）：docker images –digests</li>
<li>以filter过滤条件列出镜像列表，目前支持两种，第一个，过滤untagged镜像docker images –filter “dangling=true”；</li>
<li>第二个，过滤label，格式为label (label=<key> or label=<key>=<value>)，示例如：docker images –filter “label=com.example.version”</li>
</ul>
<p>单独描述一下format的用法，format是用来格式化输出的，使用Go语言模板实现，支持格式如下：</p>
<table>
<thead>
<tr>
<th>Placeholder</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>.ID</td>
<td>Image ID</td>
</tr>
<tr>
<td>.Repository</td>
<td>Image repository</td>
</tr>
<tr>
<td>.Tag</td>
<td>Image tag</td>
</tr>
<tr>
<td>.Digest</td>
<td>Image digest</td>
</tr>
<tr>
<td>.CreatedSince</td>
<td>Elapsed time since the image was created.</td>
</tr>
<tr>
<td>.CreatedAt</td>
<td>Time when the image was created.</td>
</tr>
<tr>
<td>.Size</td>
<td>Image disk size.</td>
</tr>
</tbody></table>
<p>例如只显示镜像的ID和repository名字：docker images –format “{ {.ID} }: { {.Repository} }”</p>
<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br><span class="line"></span><br><span class="line">Remove one or more images</span><br><span class="line"></span><br><span class="line">  -f, --force          Force removal of the image</span><br><span class="line">  --<span class="built_in">help</span>               Print usage</span><br><span class="line">  --no-prune           Do not delete untagged parents</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>镜像的长ID、短ID、tag或者digest都可以用于删除它</li>
<li>如果一个镜像有多个tag引用它，删除这个镜像之前，必须先删除所有tag引用。</li>
<li>当使用tag删除一个镜像时，她的digest引用自动会被删除</li>
<li>指定-f和镜像的ID，rmi命令会自动untag和删除所有匹配的镜像</li>
</ul>
<h3 id="查看镜像的历史"><a href="#查看镜像的历史" class="headerlink" title="查看镜像的历史"></a>查看镜像的历史</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: docker <span class="built_in">history</span> [OPTIONS] IMAGE</span><br><span class="line"></span><br><span class="line">Show the <span class="built_in">history</span> of an image</span><br><span class="line"></span><br><span class="line">  -H, --human=<span class="literal">true</span>     Print sizes and dates <span class="keyword">in</span> human readable format</span><br><span class="line">  --<span class="built_in">help</span>               Print usage</span><br><span class="line">  --no-trunc           Don<span class="string">'t truncate output</span></span><br><span class="line"><span class="string">  -q, --quiet          Only show numeric IDs</span></span><br></pre></td></tr></table></figure>

<p>history会列出镜像的build历史，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker history ubuntu</span></span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE   COMMENT</span><br><span class="line">104bec311bcd        10 weeks ago        /bin/sh -c <span class="comment">#(nop)  CMD ["/bin/bash"]            0 B</span></span><br><span class="line">&lt;missing&gt;           10 weeks ago        /bin/sh -c mkdir -p /run/systemd &amp;&amp; <span class="built_in">echo</span> <span class="string">'doc   7 B</span></span><br><span class="line"><span class="string">&lt;missing&gt;           10 weeks ago        /bin/sh -c sed -i '</span>s/^<span class="comment">#\s*\(deb.*universe\)$/   1.895 kB</span></span><br><span class="line">&lt;missing&gt;           10 weeks ago        /bin/sh -c rm -rf /var/lib/apt/lists/*          0 B</span><br><span class="line">&lt;missing&gt;           10 weeks ago        /bin/sh -c <span class="built_in">set</span> -xe   &amp;&amp; <span class="built_in">echo</span> <span class="string">'#!/bin/sh'</span> &gt; /u   745 B</span><br><span class="line">&lt;missing&gt;           10 weeks ago        /bin/sh -c <span class="comment">#(nop) ADD file:7529d28035b43a2281   128.9 MB</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>docker</category>
        <category>docker命令</category>
      </categories>
  </entry>
  <entry>
    <title>docker命令分析--简介</title>
    <url>/2017/02/23/docker_cmd_analyse/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<p>所有命令均基于docker1.11版本</p>
<h1 id="docker命令"><a href="#docker命令" class="headerlink" title="docker命令"></a>docker命令</h1><p>可以通过docker –help查看docker命令的所有功能描述。结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># docker --help</span></span><br><span class="line">Usage: docker [OPTIONS] COMMAND [arg...]</span><br><span class="line">       docker daemon [ --<span class="built_in">help</span> | ... ]</span><br><span class="line">       docker [ --<span class="built_in">help</span> | -v | --version ]</span><br><span class="line"></span><br><span class="line">A self-sufficient runtime <span class="keyword">for</span> containers.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"></span><br><span class="line">  --config=~/.docker              Location of client config files</span><br><span class="line">  -D, --debug                     Enable debug mode</span><br><span class="line">  -H, --host=[]                   Daemon socket(s) to connect to</span><br><span class="line">  -h, --<span class="built_in">help</span>                      Print usage</span><br><span class="line">  -l, --<span class="built_in">log</span>-level=info            Set the logging level</span><br><span class="line">  --tls                           Use TLS; implied by --tlsverify</span><br><span class="line">  --tlscacert=~/.docker/ca.pem    Trust certs signed only by this CA</span><br><span class="line">  --tlscert=~/.docker/cert.pem    Path to TLS certificate file</span><br><span class="line">  --tlskey=~/.docker/key.pem      Path to TLS key file</span><br><span class="line">  --tlsverify                     Use TLS and verify the remote</span><br><span class="line">  -v, --version                   Print version information and quit</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">    accel     Manage docker accelerators</span><br><span class="line">    attach    Attach to a running container</span><br><span class="line">    build     Build an image from a Dockerfile</span><br><span class="line">    commit    Create a new image from a container<span class="string">'s changes</span></span><br><span class="line"><span class="string">    cp        Copy files/folders between a container and the local filesystem</span></span><br><span class="line"><span class="string">    create    Create a new container</span></span><br><span class="line"><span class="string">    diff      Inspect changes on a container'</span>s filesystem</span><br><span class="line">    events    Get real time events from the server</span><br><span class="line">    <span class="built_in">exec</span>      Run a <span class="built_in">command</span> <span class="keyword">in</span> a running container</span><br><span class="line">    <span class="built_in">export</span>    Export a container<span class="string">'s filesystem as a tar archive</span></span><br><span class="line"><span class="string">    history   Show the history of an image</span></span><br><span class="line"><span class="string">    images    List images</span></span><br><span class="line"><span class="string">    import    Import the contents from a tarball to create a filesystem image</span></span><br><span class="line"><span class="string">    info      Display system-wide information</span></span><br><span class="line"><span class="string">    inspect   Return low-level information on a container or image</span></span><br><span class="line"><span class="string">    kill      Kill a running container</span></span><br><span class="line"><span class="string">    load      Load an image from a tar archive or STDIN</span></span><br><span class="line"><span class="string">    login     Log in to a Docker registry</span></span><br><span class="line"><span class="string">    logout    Log out from a Docker registry</span></span><br><span class="line"><span class="string">    logs      Fetch the logs of a container</span></span><br><span class="line"><span class="string">    network   Manage Docker networks</span></span><br><span class="line"><span class="string">    pause     Pause all processes within a container</span></span><br><span class="line"><span class="string">    port      List port mappings or a specific mapping for the CONTAINER</span></span><br><span class="line"><span class="string">    ps        List containers</span></span><br><span class="line"><span class="string">    pull      Pull an image or a repository from a registry</span></span><br><span class="line"><span class="string">    push      Push an image or a repository to a registry</span></span><br><span class="line"><span class="string">    rename    Rename a container</span></span><br><span class="line"><span class="string">    restart   Restart a container</span></span><br><span class="line"><span class="string">    rm        Remove one or more containers</span></span><br><span class="line"><span class="string">    rmi       Remove one or more images</span></span><br><span class="line"><span class="string">    run       Run a command in a new container</span></span><br><span class="line"><span class="string">    save      Save one or more images to a tar archive</span></span><br><span class="line"><span class="string">    search    Search the Docker Hub for images</span></span><br><span class="line"><span class="string">    start     Start one or more stopped containers</span></span><br><span class="line"><span class="string">    stats     Display a live stream of container(s) resource usage statistics</span></span><br><span class="line"><span class="string">    stop      Stop a running container</span></span><br><span class="line"><span class="string">    tag       Tag an image into a repository</span></span><br><span class="line"><span class="string">    top       Display the running processes of a container</span></span><br><span class="line"><span class="string">    unpause   Unpause all processes within a container</span></span><br><span class="line"><span class="string">    update    Update configuration of one or more containers</span></span><br><span class="line"><span class="string">    version   Show the Docker version information</span></span><br><span class="line"><span class="string">    volume    Manage Docker volumes</span></span><br><span class="line"><span class="string">    wait      Block until a container stops, then print its exit code</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Run '</span>docker COMMAND --<span class="built_in">help</span><span class="string">' for more information on a command.</span></span><br></pre></td></tr></table></figure>

<p>第一步，先介绍一下docker命令的基本格式和用法；然后，分析docker命令涉及的选项options、环境变量以及配置文件；而docker的子命令在后续的文章中详细描述。<br>需要注意，三种配置优先级：</p>
<ul>
<li>命令选项options优先于环境变量和配置文件</li>
<li>环境变量优先于配置文件</li>
</ul>
<h2 id="docker命令格式"><a href="#docker命令格式" class="headerlink" title="docker命令格式"></a>docker命令格式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker --help</span></span><br><span class="line">Usage: docker [OPTIONS] COMMAND [arg...]</span><br><span class="line">       docker daemon [ --<span class="built_in">help</span> | ... ]</span><br><span class="line">       docker [ --<span class="built_in">help</span> | -v | --version ]</span><br></pre></td></tr></table></figure>

<h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Options:</span><br><span class="line"></span><br><span class="line">  --config=~/.docker              client配置文件的路径</span><br><span class="line">  -D, --debug                     使能debug模式</span><br><span class="line">  -H, --host=[]                   docker daemon的socket文件路径</span><br><span class="line">  -h, --<span class="built_in">help</span>                      帮助手册</span><br><span class="line">  -l, --<span class="built_in">log</span>-level=info            设置日志级别</span><br><span class="line">  --tls                           Use TLS; implied by --tlsverify</span><br><span class="line">  --tlscacert=~/.docker/ca.pem    Trust certs signed only by this CA</span><br><span class="line">  --tlscert=~/.docker/cert.pem    Path to TLS certificate file</span><br><span class="line">  --tlskey=~/.docker/key.pem      Path to TLS key file</span><br><span class="line">  --tlsverify                     Use TLS and verify the remote</span><br><span class="line">  -v, --version                   打印版本信息</span><br></pre></td></tr></table></figure>

<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>docker命令行直接支持如下环境变量：</p>
<ul>
<li>DOCKER_API_VERSION – docker的API版本(例如：1.23)</li>
<li>DOCKER_CONFIG – client的配置文件路径</li>
<li>DOCKER_CERT_PATH – 证书的文件路径</li>
<li>DOCKER_DRIVER – 镜像驱动使用</li>
<li>DOCKER_HOST – docker daemon的socket文件路径</li>
<li>DOCKER_NOWARN_KERNEL_VERSION – 忽略Linux内核不适配Docker的警告</li>
<li>DOCKER_RAMDISK – If set this will disable ‘pivot_root’.</li>
<li>DOCKER_TLS_VERIFY – 设置是否使用TLS并验证远端服务</li>
<li>DOCKER_CONTENT_TRUST – When set Docker uses notary to sign and verify images. Equates to –disable-content-trust=false for build, create, pull, push, run.</li>
<li>DOCKER_CONTENT_TRUST_SERVER – The URL of the Notary server to use. This defaults to the same URL as the registry.</li>
<li>DOCKER_TMPDIR – docker临时文件存放路径</li>
</ul>
<p>由于Docker是用go开发的，所以Docker可以使用go runtime的所有环境变量，例如：</p>
<ul>
<li>HTTP_PROXY</li>
<li>HTTPS_PROXY</li>
<li>NO_PROXY</li>
</ul>
<p>注：在给Docker配置代理的时候，如果docker是用systemd启动的话，直接配置全局代理可能无效。可以使用如下方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	mkdir /etc/systemd/system/docker.service.d</span><br><span class="line">	touch /etc/systemd/system/docker.service.d/http-proxy.conf</span><br><span class="line">添加</span><br><span class="line">	[Service] Environment=<span class="string">"HTTP_PROXY=http://proxy.example.com:80/"</span></span><br><span class="line">	或者</span><br><span class="line">	Environment=<span class="string">"HTTP_PROXY=http://proxy.example.com:80/"</span> <span class="string">"NO_PROXY=localhost,127.0.0.1,docker-registry.somecorporation.com"</span></span><br><span class="line"></span><br><span class="line">刷新配置：sudo systemctl daemon-reload</span><br><span class="line">验证配置是否成功：systemctl show --property=Environment docker</span><br><span class="line">重启docker服务：sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>除了，环境变量，Docker也支持通过配置文件的方式设置一些值。配置文件默认的位置是~/.docker/，可以通过两个方式修改：</p>
<ul>
<li>设置环境变量DOCKER_CONFIG</li>
<li>设置docker命令选项–config</li>
</ul>
<p>除了config.json，配置文件目录下面其他的文件最好不好修改。config.json的配置项对应环境变量和命令行的选项的功能。<br>config.json包含很多配置项，这里只测试一下detachKeys：离开一个容器但是保持容器运行的快捷键，默认是ctrl+p,ctrl+q。这里把它修改为ctrl+e,e.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat testconfig/config.json</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"detachKeys"</span>: <span class="string">"ctrl-e,e"</span></span><br><span class="line">&#125;</span><br><span class="line">//加载配置文件</span><br><span class="line"><span class="comment"># docker --config ~/testconfig/ attach a03840eb1632</span></span><br></pre></td></tr></table></figure>

<p>这样ctrl+e,e就可以离开容器并保持容器继续运行了。</p>
<h2 id="子命令"><a href="#子命令" class="headerlink" title="子命令"></a>子命令</h2><p>后续的文章会把docker的子命令分为五类分析：</p>
<ul>
<li>镜像相关</li>
<li>容器相关</li>
<li>维测相关</li>
<li>组件相关</li>
<li>其他</li>
</ul>
]]></content>
      <categories>
        <category>docker</category>
        <category>docker命令</category>
      </categories>
  </entry>
  <entry>
    <title>docker插件简介</title>
    <url>/2017/02/14/docker_plugin/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<h1 id="docker-engine管理plugin系统"><a href="#docker-engine管理plugin系统" class="headerlink" title="docker engine管理plugin系统"></a>docker engine管理plugin系统</h1><p>docker plugin系统支持安装、启动、停止和删除docker引擎使用的插件。当前该机制只支持volume驱动，后续会支持更多。</p>
<h2 id="安装与使用plugin"><a href="#安装与使用plugin" class="headerlink" title="安装与使用plugin"></a>安装与使用plugin</h2><p>插件以容器镜像的方式发布，可以保存到Docker Hub或者私有registry。<br>插件相关命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker plugin install   //安装</span><br><span class="line">docker plugin ls        //检查安装插件</span><br></pre></td></tr></table></figure>
<p>该命令会从Docker Hub或者私有registry下拉插件，提示你需要的权限或者capabilities，并且使能插件。</p>
<p>安装sshfs插件示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker plugin install vieux/sshfs</span><br><span class="line"></span><br><span class="line">Plugin <span class="string">"vieux/sshfs"</span> is requesting the following privileges:</span><br><span class="line">- network: [host]</span><br><span class="line">- capabilities: [CAP_SYS_ADMIN]</span><br><span class="line">Do you grant the above permissions? [y/N] y</span><br><span class="line"></span><br><span class="line">vieux/sshfs</span><br><span class="line"></span><br><span class="line">$ docker plugin ls</span><br><span class="line"></span><br><span class="line">ID                    NAME                  TAG                 DESCRIPTION                   ENABLED</span><br><span class="line">69553ca1d789          vieux/sshfs           latest              the `sshfs` plugin            <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>使用sshfs插件创建数据卷：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker volume create -d vieux/sshfs -o sshcmd=&lt;user@host:path&gt; -o password=&lt;password&gt; sshvolume</span><br><span class="line">sshvolume</span><br><span class="line">$ docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>               2d75de358a70ba469ac968ee852efd4234b9118b7722ee26a1c5a90dcaea6751</span><br><span class="line"><span class="built_in">local</span>               842a765a9bb11e234642c933b3dfc702dee32b73e0cf7305239436a145b89017</span><br><span class="line"><span class="built_in">local</span>               9d72c664cbd20512d4e3d5bb9b39ed11e4a632c386447461d48ed84731e44034</span><br><span class="line"><span class="built_in">local</span>               be9632386a2d396d438c9707e261f86fd9f5e72a7319417901d84041c8f14a4d</span><br><span class="line"><span class="built_in">local</span>               e1496dfe4fa27b39121e4383d1b16a0a7510f0de89f05b336aab3c0deb4dda0e</span><br><span class="line">vieux/sshfs         sshvolume</span><br></pre></td></tr></table></figure>

<h1 id="开发plugin"><a href="#开发plugin" class="headerlink" title="开发plugin"></a>开发plugin</h1>]]></content>
      <categories>
        <category>docker</category>
        <category>docker plugin</category>
      </categories>
  </entry>
  <entry>
    <title>容器内调用reboot函数失败</title>
    <url>/2017/02/08/container_reboot/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在容器里面调用reboot函数，函数传入LINUX_REBOOT_CMD_CAD_ON, LINUX_REBOOT_CMD_CAD_OFF这两个参数都返回失败。<br>reboot return -1,errno is 22(EINVAL)</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>查看官方文档(<a href="http://man7.org/linux/man-pages/man2/reboot.2.html)：" target="_blank" rel="noopener">http://man7.org/linux/man-pages/man2/reboot.2.html)：</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Behavior inside PID namespaces</span><br><span class="line">      Since Linux 3.4, when reboot() is called from a PID namespace (see</span><br><span class="line">      pid_namespaces(7)) other than the initial PID namespace, the effect</span><br><span class="line">      of the call is to send a signal to the namespace <span class="string">"init"</span> process.  The</span><br><span class="line">      LINUX_REBOOT_CMD_RESTART and LINUX_REBOOT_CMD_RESTART2 cmd values</span><br><span class="line">      cause a SIGHUP signal to be sent.  The LINUX_REBOOT_CMD_POWER_OFF and</span><br><span class="line">      LINUX_REBOOT_CMD_HALT cmd values cause a SIGINT signal to be sent.</span><br><span class="line">      For the other cmd values, -1 is returned and errno is <span class="built_in">set</span> to EINVAL.</span><br></pre></td></tr></table></figure>
<p>上面的意思大概是：在非initial PID namespace中，调用reboot，会给init进程发送信号，信号取决于cmd的值。</p>
<ul>
<li>LINUX_REBOOT_CMD_RESTART 和 LINUX_REBOOT_CMD_RESTART2，会发送SIGHUP信号</li>
<li>LINUX_REBOOT_CMD_POWER_OFF 和 LINUX_REBOOT_CMD_HALT，发送SIGINT信号</li>
<li>其他的直接返回-1，errno为EINVAL</li>
</ul>
<p>这里可以推出我们在容器中执行reboot，入参为LINUX_REBOOT_CMD_CAD_ON, LINUX_REBOOT_CMD_CAD_OFF时，会报错的原因。</p>
<p>查看reboot系统调用的源码验证一下官方文档，部分代码如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE4(reboot, int, magic1, int, magic2, unsigned int, cmd,</span><br><span class="line">		void __user *, arg)</span><br><span class="line">&#123;</span><br><span class="line">	struct pid_namespace *pid_ns = task_active_pid_ns(current);</span><br><span class="line">	char buffer[256];</span><br><span class="line">	int ret = 0;</span><br><span class="line"></span><br><span class="line">	/* We only trust the superuser with rebooting the system. */</span><br><span class="line">	<span class="keyword">if</span> (!ns_capable(pid_ns-&gt;user_ns, CAP_SYS_BOOT))</span><br><span class="line">		<span class="built_in">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">	/* For safety, we require <span class="string">"magic"</span> arguments. */</span><br><span class="line">	<span class="keyword">if</span> (magic1 != LINUX_REBOOT_MAGIC1 ||</span><br><span class="line">	    (magic2 != LINUX_REBOOT_MAGIC2 &amp;&amp;</span><br><span class="line">	                magic2 != LINUX_REBOOT_MAGIC2A &amp;&amp;</span><br><span class="line">			magic2 != LINUX_REBOOT_MAGIC2B &amp;&amp;</span><br><span class="line">	                magic2 != LINUX_REBOOT_MAGIC2C))</span><br><span class="line">		<span class="built_in">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If pid namespaces are enabled and the current task is <span class="keyword">in</span> a child</span><br><span class="line">	 * pid_namespace, the <span class="built_in">command</span> is handled by reboot_pid_ns() <span class="built_in">which</span> will</span><br><span class="line">	 * call do_exit().</span><br><span class="line">	 */</span><br><span class="line">	ret = reboot_pid_ns(pid_ns, cmd);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="built_in">return</span> ret;</span><br><span class="line">    ... ...</span><br></pre></td></tr></table></figure>

<p>关键是reboot_pid_ns函数，该函数代码如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int reboot_pid_ns(struct pid_namespace *pid_ns, int cmd)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pid_ns == &amp;init_pid_ns)</span><br><span class="line">		<span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line">	switch (cmd) &#123;</span><br><span class="line">	<span class="keyword">case</span> LINUX_REBOOT_CMD_RESTART2:</span><br><span class="line">	<span class="keyword">case</span> LINUX_REBOOT_CMD_RESTART:</span><br><span class="line">		pid_ns-&gt;reboot = SIGHUP;</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> LINUX_REBOOT_CMD_POWER_OFF:</span><br><span class="line">	<span class="keyword">case</span> LINUX_REBOOT_CMD_HALT:</span><br><span class="line">		pid_ns-&gt;reboot = SIGINT;</span><br><span class="line">		<span class="built_in">break</span>;</span><br><span class="line">	default:</span><br><span class="line">		<span class="built_in">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	read_lock(&amp;tasklist_lock);</span><br><span class="line">	force_sig(SIGKILL, pid_ns-&gt;child_reaper);</span><br><span class="line">	read_unlock(&amp;tasklist_lock);</span><br><span class="line"></span><br><span class="line">	do_exit(0);</span><br><span class="line"></span><br><span class="line">	/* Not reached */</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码解析：</p>
<ul>
<li>如果当前的namespace是init_pid_ns，就返回0</li>
<li>非init_pid_ns时，就如上面文档所述，非指定的cmd，就直接返回EINVAL</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
        <category>docker</category>
        <category>reboot</category>
      </categories>
  </entry>
  <entry>
    <title>Linux打开文件的上限分析</title>
    <url>/2017/02/06/linux_file_nr_max/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<p>Linux打开文件的上限，主要受文件句柄上限和文件描述符上限的限制。</p>
<ul>
<li>文件句柄： A file handle is a pointer to an actual data structure </li>
<li>文件描述符： A file descriptor is a just an abstract key for accessing the file</li>
</ul>
<p>因此，文件句柄和文件描述符是不一样的。</p>
<h2 id="相关函数简介"><a href="#相关函数简介" class="headerlink" title="相关函数简介"></a>相关函数简介</h2><p>函数getdtablesize，获取文件描述符表格的大小。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getdtablesize() returns the maximum number of files a process can</span><br><span class="line">have open, one more than the largest possible value for a file</span><br><span class="line">descriptor.</span><br><span class="line">系统调用如下：</span><br><span class="line">SYSCALL_DEFINE0(getdtablesize)</span><br><span class="line">&#123;</span><br><span class="line">	return sysctl_nr_open;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="文件描述符上限相关"><a href="#文件描述符上限相关" class="headerlink" title="文件描述符上限相关"></a>文件描述符上限相关</h2><p>文件描述符上限可以同ulimit进行设置，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -n 64000</span><br></pre></td></tr></table></figure>

<p>获取当前文件描述符的上限，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cat &#x2F;proc&#x2F;self&#x2F;limits</span><br><span class="line">Limit                     Soft Limit           Hard Limit           Units</span><br><span class="line">Max cpu time              unlimited            unlimited            seconds</span><br><span class="line">Max file size             unlimited            unlimited            bytes</span><br><span class="line">Max data size             unlimited            unlimited            bytes</span><br><span class="line">Max stack size            8388608              unlimited            bytes</span><br><span class="line">Max core file size        unlimited            unlimited            bytes</span><br><span class="line">Max resident set          unlimited            unlimited            bytes</span><br><span class="line">Max processes             1048576              1048576              processes</span><br><span class="line"></span><br><span class="line">Max open files            64000                64000                files</span><br><span class="line"></span><br><span class="line">Max locked memory         65536                65536                bytes</span><br><span class="line">Max address space         unlimited            unlimited            bytes</span><br><span class="line">Max file locks            unlimited            unlimited            locks</span><br><span class="line">Max pending signals       10546                10546                signals</span><br><span class="line">Max msgqueue size         819200               819200               bytes</span><br><span class="line">Max nice priority         0                    0</span><br><span class="line">Max realtime priority     0                    0</span><br><span class="line">Max realtime timeout      unlimited            unlimited            us</span><br></pre></td></tr></table></figure>
<p>如上所示，Max open files为我们设置的64000。</p>
<h2 id="文件句柄相关"><a href="#文件句柄相关" class="headerlink" title="文件句柄相关"></a>文件句柄相关</h2><p>系统使用的文件句柄的统计数据放在/proc/sys/fs/file-nr文件中，该文件包含三部分：</p>
<ul>
<li>已分配的文件句柄数</li>
<li>分配但未使用的文件句柄数</li>
<li>最大的文件句柄数</li>
</ul>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /proc/sys/fs/file-nr</span></span><br><span class="line">896	0	267456</span><br></pre></td></tr></table></figure>

<p>上述的数据，在内核中是保存在结构体files_stat_struct的变量files_stat中，该值在files_init函数中初始化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* And dynamically-tunable limits and defaults: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_stat_struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> nr_files;		<span class="comment">/* read only */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> nr_free_files;	<span class="comment">/* read only */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> max_files;		<span class="comment">/* tunable */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* sysctl tunables... */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_stat_struct</span> <span class="title">files_stat</span> = &#123;</span></span><br><span class="line">	.max_files = NR_FILE    <span class="comment">/* This constant is 8192 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">files_init</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> mempages)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> n;</span><br><span class="line"></span><br><span class="line">  filp_cachep = kmem_cache_create(<span class="string">"filp"</span>, <span class="keyword">sizeof</span>(struct file), <span class="number">0</span>,</span><br><span class="line">      SLAB_HWCACHE_ALIGN | SLAB_PANIC, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * One file with associated inode and dcache is very roughly 1K.</span></span><br><span class="line"><span class="comment">   * Per default don't use more than 10% of our memory for files. </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  n = (mempages * (PAGE_SIZE / <span class="number">1024</span>)) / <span class="number">10</span>;</span><br><span class="line">  files_stat.max_files = <span class="keyword">max_t</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>, n, NR_FILE);</span><br><span class="line">  files_defer_init();</span><br><span class="line">  lg_lock_init(files_lglock);</span><br><span class="line">  percpu_counter_init(&amp;nr_files, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从函数files_init中可以知道，文件句柄的最大值等于NR_FILE或者10%的内存。因此，文件句柄的上限取决于系统的内存大小。</p>
<p>参考文章：</p>
<p>[1] <a href="http://serverfault.com/questions/716578/default-value-of-proc-sys-fs-file-max" target="_blank" rel="noopener">http://serverfault.com/questions/716578/default-value-of-proc-sys-fs-file-max</a><br>[2] <a href="http://www.linuxvox.com/2015/12/what-are-file-max-and-file-nr-linux-kernel-parameters/" target="_blank" rel="noopener">http://www.linuxvox.com/2015/12/what-are-file-max-and-file-nr-linux-kernel-parameters/</a></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>文件</category>
      </categories>
  </entry>
  <entry>
    <title>Docker容器可视化</title>
    <url>/2017/01/24/docker_visual/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<h1 id="Google的cadvisor项目"><a href="#Google的cadvisor项目" class="headerlink" title="Google的cadvisor项目"></a>Google的cadvisor项目</h1><p>cadvisor用于分析运行容器的资源使用和利用率。cadvisor本身已经容器化，应该使用起来非常简单。<br>cadvisor的项目地址：<a href="https://github.com/google/cadvisor" target="_blank" rel="noopener">https://github.com/google/cadvisor</a><br>下载cadvisor的镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull google/cadvisor</span><br></pre></td></tr></table></figure>

<p>启动cadvisor的容器服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker run \</span><br><span class="line">  --volume=/:/rootfs:ro \</span><br><span class="line">  --volume=/var/run:/var/run:rw \</span><br><span class="line">  --volume=/sys:/sys:ro \</span><br><span class="line">  --volume=/var/lib/docker/:/var/lib/docker:ro \</span><br><span class="line">  --publish=8070:8080 \</span><br><span class="line">  --detach=<span class="literal">true</span> \</span><br><span class="line">  --name=cadvisor \</span><br><span class="line">  google/cadvisor:latest</span><br></pre></td></tr></table></figure>

<p>通过IP或者域名加端口号访问，就可以可视化的看到机器上运行的容器的资源使用情况了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://&lt;hostname&gt;:&lt;port&gt;/</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>docker</category>
        <category>可视化</category>
      </categories>
  </entry>
  <entry>
    <title>Docker update命令分析</title>
    <url>/2017/01/19/docker_update/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<p>update命令的主要作用：动态更新容器的配置。<br>注意：</p>
<ul>
<li>可以同时指定多个容器， 容器之间以空格间隔</li>
<li>对于–kernel-memory，只能对stopped容器进行更新。其它的配置支持running或stoped的容器。</li>
</ul>
<p>然后，看看官方手册，docker update的用法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage:  docker update [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line">Update configuration of one or more containers</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --blkio-weight value          Block IO (relative weight), between 10 and 1000</span><br><span class="line">      --cpu-period int              Limit CPU CFS (Completely Fair Scheduler) period</span><br><span class="line">      --cpu-quota int               Limit CPU CFS (Completely Fair Scheduler) quota</span><br><span class="line">  -c, --cpu-shares int              CPU shares (relative weight)</span><br><span class="line">      --cpuset-cpus string          CPUs <span class="keyword">in</span> <span class="built_in">which</span> to allow execution (0-3, 0,1)</span><br><span class="line">      --cpuset-mems string          MEMs <span class="keyword">in</span> <span class="built_in">which</span> to allow execution (0-3, 0,1)</span><br><span class="line">      --<span class="built_in">help</span>                        Print usage</span><br><span class="line">      --kernel-memory string        Kernel memory <span class="built_in">limit</span></span><br><span class="line">  -m, --memory string               Memory <span class="built_in">limit</span></span><br><span class="line">      --memory-reservation string   Memory soft <span class="built_in">limit</span></span><br><span class="line">      --memory-swap string          Swap <span class="built_in">limit</span> equal to memory plus swap: <span class="string">'-1'</span> to <span class="built_in">enable</span> unlimited swap</span><br><span class="line">      --restart string              Restart policy to apply when a container exits</span><br></pre></td></tr></table></figure>

<h3 id="CPU相关参数"><a href="#CPU相关参数" class="headerlink" title="CPU相关参数"></a>CPU相关参数</h3><p>cpu-shares参数：设置容器的CPU占用的相对权重，如果有两容器在一个核上面运行，一个cpu-shares设置为1024，一个设置为512，<br>那么这两个占用CPU时间的比例为2/1。<br>此功能和cpuset-cpus参数一起使用，结果比较容易呈现。<br>启动三个容器，cpu-shares分别为1024，1024，和512，cpuset-cpus=1。启动脚本如下(cpurun.sh就是一个while(1))：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -td --cpu-shares=512 --cpuset-cpus=1 -v /workspace:/<span class="built_in">test</span> ubuntu sh -c <span class="string">"/test/cpurun.sh"</span></span><br><span class="line">docker run -td --cpu-shares=1024 --cpuset-cpus=1 -v /workspace:/<span class="built_in">test</span> ubuntu sh -c <span class="string">"/test/cpurun.sh"</span></span><br><span class="line">docker run -td --cpu-shares=1024 --cpuset-cpus=1 -v /workspace:/<span class="built_in">test</span> ubuntu sh -c <span class="string">"/test/cpurun.sh"</span></span><br></pre></td></tr></table></figure>

<p>top查看三个进程的cpu占有率，结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">17970 root      20   0    3852   1764   1104 S  15.0  0.0   0:19.35 sh</span><br><span class="line">18172 root      20   0    3852   1764   1104 S  15.0  0.0   0:11.47 sh</span><br><span class="line">  850 root      20   0  223264  42416  13860 S  13.7  0.5   2:44.50 docker</span><br><span class="line">28127 root      20   0    3464   1408   1104 S   8.0  0.0   0:01.25 sh</span><br></pre></td></tr></table></figure>

<p>结果很明显，cpu占比的比例接近2：2：1.</p>
]]></content>
      <categories>
        <category>docker</category>
        <category>docker命令</category>
      </categories>
  </entry>
  <entry>
    <title>从源码安装tmux</title>
    <url>/2017/01/17/install_tmux/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<h2 id="安装libevent"><a href="#安装libevent" class="headerlink" title="安装libevent"></a>安装libevent</h2><p>首先，需要到官网(<a href="http://libevent.org/)去下载最新的源码，安装流程如下：" target="_blank" rel="noopener">http://libevent.org/)去下载最新的源码，安装流程如下：</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate https://github.com/libevent/libevent/releases/download/release-2.0.22-stable/libevent-2.0.22-stable.tar.gz</span><br><span class="line">tar -zxf libevent-2.0.22-stable.tar.gz</span><br><span class="line"><span class="built_in">cd</span> libevent-2.0.22-stable</span><br><span class="line">./configure -prefix=/usr</span><br><span class="line">make -j4</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h2 id="安装ncurses"><a href="#安装ncurses" class="headerlink" title="安装ncurses"></a>安装ncurses</h2><p>tmux依赖ncurses，因此需要先安装ncurses，同样通过源码安装，脚本如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://invisible-island.net/datafiles/release/ncurses.tar.gz</span><br><span class="line">tar -zxf ncurses.tar.gz</span><br><span class="line"><span class="built_in">cd</span> ncurses-5.9/</span><br><span class="line">./configure</span><br><span class="line">make -j4</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h2 id="安装tmux"><a href="#安装tmux" class="headerlink" title="安装tmux"></a>安装tmux</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt-get install automake  <span class="comment">#依赖aclocal命令</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/tmux/tmux.git</span><br><span class="line">$ <span class="built_in">cd</span> tmux</span><br><span class="line">$ sh autogen.sh</span><br><span class="line">$ ./configure -prefix=/usr <span class="comment">#注意prefix，不然安装到/usr/local/bin目录，可能执行不了</span></span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure>

<p>tmux已经安装，成功了！！！</p>
]]></content>
      <categories>
        <category>tmux</category>
        <category>ubuntu14.04</category>
        <category>linux工具</category>
      </categories>
  </entry>
  <entry>
    <title>Systemd自动Unmount机制分析</title>
    <url>/2017/01/17/mount_enumerate/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<p>遇到过systemd会自动unmount一些目录，导致异常。那么systemd为什么会出现autounmount的情况呢？<br>这里进行简单的分析一下。</p>
<p>注：该异常的systemd版本为systemd-219-19.el7.x86_64</p>
<h3 id="异常必现的方式"><a href="#异常必现的方式" class="headerlink" title="异常必现的方式"></a>异常必现的方式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lin ~]<span class="comment"># mount -t ramfs /dev/nonexistent /hello/kitty</span></span><br><span class="line">[root@lin ~]<span class="comment"># echo $?</span></span><br><span class="line">0</span><br><span class="line">[root@lin ~]<span class="comment"># mount | grep /hello/kitty</span></span><br><span class="line">[root@lin ~]<span class="comment"># umount /hello/kitty</span></span><br><span class="line">umount: /hello/kitty: not mounted</span><br><span class="line">[root@lin ~]<span class="comment"># rmdir /hello/kitty</span></span><br></pre></td></tr></table></figure>
<p>这里的/dev/nonexistent表示该设备不存在，注意这里必现是/dev目录下的才能触发该异常。<br>查看/var/log/message会发现日志如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Jun  1 11:07:44 ws systemd: Unit hello-kitty.mount is bound to inactive unit dev-littlecat.device. Stopping, too.</span><br><span class="line">Jun  1 11:07:44 ws systemd: Unmounting &#x2F;hello&#x2F;kitty...</span><br><span class="line">Jun  1 11:07:44 ws systemd: Unmounted &#x2F;hello&#x2F;kitty.</span><br></pre></td></tr></table></figure>

<p>参考文档：</p>
<ul>
<li><a href="https://bugzilla.redhat.com/show_bug.cgi?id=1226528" target="_blank" rel="noopener">Bug 1226528 - unwanted automatic umount when device does not exist for nondev fs</a></li>
<li><a href="https://github.com/systemd/systemd/commit/fcd8b266edf0df2b85079fcf7b099cd4028740e6#diff-a55dd3f995e0ee0a2ba83f24f9492eeb" target="_blank" rel="noopener">对应PATCH</a></li>
</ul>
<h3 id="监听mountinfo"><a href="#监听mountinfo" class="headerlink" title="监听mountinfo"></a>监听mountinfo</h3><p>监听mountinfo调用流程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">src&#x2F;core&#x2F;main.c  main</span><br><span class="line">    --&gt; src&#x2F;core&#x2F;manager.c  manager_startup</span><br><span class="line">        --&gt; src&#x2F;core&#x2F;manager.c  manager_enumerate </span><br><span class="line">            --&gt; src&#x2F;core&#x2F;mount.c  mount_enumerate</span><br><span class="line">                --&gt; src&#x2F;libsystemd&#x2F;sd-event&#x2F;sd-event.c  sd_event_add_io</span><br><span class="line">                    --&gt; &#x2F;src&#x2F;libsystemd&#x2F;sd-event&#x2F;sd-event.c  source_io_register</span><br></pre></td></tr></table></figure>

<p>注：manager_enumerate会加载所有的units，执行enumerate操作，由于mount的unit对应的是mount_enumerate。<br>因此，会调用mount_enumerate函数。</p>
<p>mount_enumerate中注册的调用如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sd_event_add_io(m-&gt;event, &amp;m-&gt;mount_event_source, </span><br><span class="line">                fileno(m-&gt;proc_self_mountinfo), </span><br><span class="line">                EPOLLPRI, </span><br><span class="line">                mount_dispatch_io, </span><br><span class="line">                m);</span><br><span class="line"></span><br><span class="line">sd_event_add_io(m-&gt;event, &amp;m-&gt;mount_utab_event_source, </span><br><span class="line">                m-&gt;utab_inotify_fd, </span><br><span class="line">                EPOLLIN, </span><br><span class="line">                mount_dispatch_io, </span><br><span class="line">                m);</span><br></pre></td></tr></table></figure>

<p>需要注意：</p>
<ul>
<li>fileno(m-proc_self_mountinfo)，这个就是获取文件“/proc/self/mountinfo”的句柄。</li>
<li>EPOLLPRI，是epoll机制使用的参数，表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）</li>
<li>mount_dispatch_io，表示接收到事件时，触发的回调处理函数。</li>
<li>m-&gt;utab_inotify_fd,对应于文件“/run/mount”</li>
<li>EPOLLIN，是epoll机制使用的参数，表示有可读数据。</li>
</ul>
<p>sd_event_add_io函数事件调用的是source_io_register函数进行注册，它基于epoll机制实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;source_io_register函数实现</span><br><span class="line">    ......</span><br><span class="line">        if (s-&gt;io.registered)</span><br><span class="line">                r &#x3D; epoll_ctl(s-&gt;event-&gt;epoll_fd, EPOLL_CTL_MOD, s-&gt;io.fd, &amp;ev);</span><br><span class="line">        else</span><br><span class="line">                r &#x3D; epoll_ctl(s-&gt;event-&gt;epoll_fd, EPOLL_CTL_ADD, s-&gt;io.fd, &amp;ev);</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>

<p>如果event已经注册，这通过EPOLL_CTL_MOD入参，进行更新，否则增加该event的监听。</p>
<p>这一串的调用，其实就是注册监听文件“/proc/self/mountinfo”或者“/run/mount”，当该文件有数据可读时，会触发回调函数mount_dispatch_io。</p>
<h3 id="回调函数mount-dispatch-io"><a href="#回调函数mount-dispatch-io" class="headerlink" title="回调函数mount_dispatch_io"></a>回调函数mount_dispatch_io</h3><p>发现”/proc/self/mountinfo”有新的mount，添加mount unit的流程以及添加需要umount依赖的流程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--&gt;  src&#x2F;core&#x2F;mount.c  mount_load_proc_self_mountinfo</span><br><span class="line">    --&gt; src&#x2F;core&#x2F;mount.c  mount_setup_unit</span><br><span class="line">        --&gt;  src&#x2F;core&#x2F;mount.c  unit_new</span><br><span class="line">        --&gt;  src&#x2F;core&#x2F;mount.c  should_umount</span><br><span class="line">        --&gt;  src&#x2F;core&#x2F;mount.c  unit_add_dependency_by_name -- UNIT_CONFLICTS -- SPECIAL_UMOUNT_TARGET</span><br></pre></td></tr></table></figure>

<p>发现设备状态变化，触发unmount的调用流程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--&gt;  src&#x2F;core&#x2F;device.c  device_found_node</span><br><span class="line">    --&gt; src&#x2F;core&#x2F;device.c  device_update_found_by_name</span><br><span class="line">        --&gt; src&#x2F;core&#x2F;device.c  device_update_found_one</span><br><span class="line">            --&gt; src&#x2F;core&#x2F;device.c  device_set_state</span><br><span class="line">                --&gt; src&#x2F;core&#x2F;unit.c  unit_notify</span><br><span class="line">                    --&gt; src&#x2F;core&#x2F;job.c  job_finish_and_invalidate  -- JOB_STOP -- UNIT_CONFLICTED_BY</span><br><span class="line">                    --&gt; src&#x2F;core&#x2F;job.c  job_finish_and_invalidate</span><br></pre></td></tr></table></figure>

<h3 id="修复PATCH分析"><a href="#修复PATCH分析" class="headerlink" title="修复PATCH分析"></a>修复PATCH分析</h3><ul>
<li>PATCH的unmount标准：识别出非mounted对应的what，并且识别just_mounted和just_changed的what。用于触发umount流程时，判断需要umount那些mount。</li>
<li>未打该PATCH之前的标准：所有非mounted的而且what不为空的mount，都会触发unmount流程。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (!mount-&gt;is_mounted) &#123;</span><br><span class="line">  </span><br><span class="line">+                        &#x2F;* A mount point is gone *&#x2F;</span><br><span class="line">+</span><br><span class="line">                          mount-&gt;from_proc_self_mountinfo &#x3D; false;</span><br><span class="line">  </span><br><span class="line">                          switch (mount-&gt;state) &#123;</span><br><span class="line"> @@ -1710,13 +1715,17 @@ static int mount_dispatch_io(sd_event_source *source, int fd, uint32_t revents,</span><br><span class="line">                                  break;</span><br><span class="line">                          &#125;</span><br><span class="line">  </span><br><span class="line"> -                        if (mount-&gt;parameters_proc_self_mountinfo.what)</span><br><span class="line"> -                                (void) device_found_node(m, mount-&gt;parameters_proc_self_mountinfo.what, false, DEVICE_FOUND_MOUNT, true);</span><br><span class="line"> +                        &#x2F;* Remember that this device might just have disappeared *&#x2F;</span><br><span class="line"> +                        if (mount-&gt;parameters_proc_self_mountinfo.what) &#123;</span><br><span class="line">  </span><br><span class="line"> +                                if (set_ensure_allocated(&amp;gone, &amp;string_hash_ops) &lt; 0 ||</span><br><span class="line"> +                                    set_put(gone, mount-&gt;parameters_proc_self_mountinfo.what) &lt; 0)</span><br><span class="line"> +                                        log_oom(); &#x2F;* we don&#39;t care too much about OOM here... *&#x2F;</span><br><span class="line"> +                        &#125;</span><br><span class="line">  </span><br><span class="line">                  &#125; else if (mount-&gt;just_mounted || mount-&gt;just_changed) &#123;</span><br><span class="line">  </span><br><span class="line"> -                        &#x2F;* New or changed mount entry *&#x2F;</span><br><span class="line"> +                        &#x2F;* A mount point was added or changed *&#x2F;</span><br><span class="line">  </span><br><span class="line">                          switch (mount-&gt;state) &#123;</span><br><span class="line">  </span><br><span class="line"> @@ -1741,12 +1750,27 @@ static int mount_dispatch_io(sd_event_source *source, int fd, uint32_t revents,</span><br><span class="line">                                  mount_set_state(mount, mount-&gt;state);</span><br><span class="line">                                  break;</span><br><span class="line">                          &#125;</span><br><span class="line"> +</span><br><span class="line"> +                        if (mount-&gt;parameters_proc_self_mountinfo.what) &#123;</span><br><span class="line"> +</span><br><span class="line"> +                                if (set_ensure_allocated(&amp;around, &amp;string_hash_ops) &lt; 0 ||</span><br><span class="line"> +                                    set_put(around, mount-&gt;parameters_proc_self_mountinfo.what) &lt; 0)</span><br><span class="line"> +                                        log_oom();</span><br><span class="line"> +                        &#125;</span><br><span class="line">                  &#125;</span><br></pre></td></tr></table></figure>

<p>触发不在around中的device的Unmount流程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+        SET_FOREACH(what, gone, i) &#123;</span><br><span class="line">+                if (set_contains(around, what))</span><br><span class="line">+                        continue;</span><br><span class="line">+</span><br><span class="line">+                &#x2F;* Let the device units know that the device is no longer mounted *&#x2F;</span><br><span class="line">+                (void) device_found_node(m, what, false, DEVICE_FOUND_MOUNT, true);</span><br><span class="line">+        &#125;</span><br></pre></td></tr></table></figure>

<p>注：what其实就是device</p>
]]></content>
      <categories>
        <category>systemd</category>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>Python杂记</title>
    <url>/2017/01/17/python_notes_1/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<p>最近被python的条件坑了一波，在此小计一下。<br>python的IF的条件判断和C是一致的，0表示False，非0表示True。这本没什么问题，坑爹的是，很多函数的成功返回0，而失败返回-1，这就很容易被坑了。<br>先看看0和-1的情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">root@rtos:/home/work/rtos<span class="comment"># python</span></span><br><span class="line">Python 2.7.6 (default, Oct 26 2016, 20:30:19)</span><br><span class="line">[GCC 4.8.4] on linux2</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> or <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">if</span> 0:</span><br><span class="line">...     <span class="built_in">print</span>(<span class="string">"0 is True"</span>)</span><br><span class="line">... <span class="keyword">else</span>:</span><br><span class="line">...     <span class="built_in">print</span>(<span class="string">"0 is False"</span>)</span><br><span class="line">...</span><br><span class="line">0 is False</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">if</span> -1:</span><br><span class="line">...     <span class="built_in">print</span>(<span class="string">"-1 is True"</span>)</span><br><span class="line">... <span class="keyword">else</span>:</span><br><span class="line">...     <span class="built_in">print</span>(<span class="string">"-1 is False"</span>)</span><br><span class="line">...</span><br><span class="line">-1 is True</span><br></pre></td></tr></table></figure>

<p>字符串的find函数，在查找失败的时候返回-1，成功时返回匹配的起始下标。当匹配的起始下标是0和查找失败的时候，在if判断时候需要注意了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt; tmp = <span class="string">"abcdefg"</span></span><br><span class="line">&gt;&gt;&gt; a = <span class="string">"abc"</span></span><br><span class="line">&gt;&gt;&gt; b = <span class="string">"bcd"</span></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">if</span> tmp.find(a):</span><br><span class="line">...     <span class="built_in">print</span>(<span class="string">"%s find in %s"</span> % (a, tmp))</span><br><span class="line">... <span class="keyword">else</span>:</span><br><span class="line">...     <span class="built_in">print</span>(<span class="string">"%s cannot find in %s"</span> % (a, tmp))</span><br><span class="line">...</span><br><span class="line">abc cannot find <span class="keyword">in</span> abcdefg</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">if</span> tmp.find(b):</span><br><span class="line">...     <span class="built_in">print</span>(<span class="string">"%s find in %s"</span> % (b, tmp))</span><br><span class="line">... <span class="keyword">else</span>:</span><br><span class="line">...     <span class="built_in">print</span>(<span class="string">"%s cannot find in %s"</span> % (b, tmp))</span><br><span class="line">...</span><br><span class="line">bcd find <span class="keyword">in</span> abcdefg</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; c = <span class="string">"234"</span></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">if</span> tmp.find(c):</span><br><span class="line">...     <span class="built_in">print</span>(<span class="string">"%s find in %s"</span> % (c, tmp))</span><br><span class="line">... <span class="keyword">else</span>:</span><br><span class="line">...     <span class="built_in">print</span>(<span class="string">"%s cannot find in %s"</span> % (c, tmp))</span><br><span class="line">...</span><br><span class="line">234 find <span class="keyword">in</span> abcdefg</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>搭建本地的Docker registry</title>
    <url>/2017/01/03/create_local_registry/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<h2 id="搭建非安全Registry"><a href="#搭建非安全Registry" class="headerlink" title="搭建非安全Registry"></a>搭建非安全Registry</h2><p>Docker官方hub上面已提供容器化的Registry，可以通过docker run直接启动一个本地的Registry的服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 5000:5000 \</span><br><span class="line">    --restart=always --name registry registry:2</span><br></pre></td></tr></table></figure>

<p>上传镜像的方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull ubuntu</span><br><span class="line">docker tag ubuntu localhost:5000/ubuntu</span><br><span class="line">docker push localhost:5000/ubuntu</span><br></pre></td></tr></table></figure>

<p>可以通过数据卷的方式，把上传的docker镜像保存到指定的host目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 5000:5000 --restart=always --name registry \</span><br><span class="line">  -v /data:/var/lib/registry \</span><br><span class="line">  registry:2</span><br></pre></td></tr></table></figure>
<h3 id="跨机器访问非安全Registry"><a href="#跨机器访问非安全Registry" class="headerlink" title="跨机器访问非安全Registry"></a>跨机器访问非安全Registry</h3><p>跨机器访问非安全的Registry，需要对机器的Docker daemon的启动参数进行设置，设置方法取决于docker daemon的启动方式。<br>以Ubuntu为例：</p>
<ul>
<li>修改/etc/default/docker文件</li>
<li>添加DOCKER_OPTS=”–insecure-registry myregistrydomain.com:5000”，以myregistrydomain.com为例，也可以是IP地址</li>
<li>重启Docker daemon服务</li>
</ul>
<h2 id="搭建安全Registry"><a href="#搭建安全Registry" class="headerlink" title="搭建安全Registry"></a>搭建安全Registry</h2><p>首先，需要对openssl的配置做一些修改：</p>
<ul>
<li>Ubuntu配置文件： /etc/ssl/openssl.cnf</li>
<li>Redhat配置文件： /etc/pki/tls/openssl.cnf</li>
</ul>
<p>注：在上面的配置文件的[ v3_ca ]标签下面加上subjectAltName=IP:192.168.1.181 &lt;192.168.1.181为当期机器的IP&gt;<br>参考文章：<a href="http://dockone.io/article/684" target="_blank" rel="noopener">http://dockone.io/article/684</a></p>
<p>可以通过openssl生成自己的证书和密钥，用来验证。生成证书的方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /certs &amp;&amp; openssl req \</span><br><span class="line">   -newkey rsa:4096 -nodes -sha256 -keyout certs/domain.key \</span><br><span class="line">   -x509 -days 365 -out certs/domain.crt</span><br></pre></td></tr></table></figure>

<p>关于openssl生成密钥的办法还有下面的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> subjectAltName = DNS:<span class="variable">$HOST</span>,IP:10.10.10.20,IP:127.0.0.1 &gt; extfile.cnf</span><br><span class="line">$ openssl x509 -req -days 365 -sha256 -<span class="keyword">in</span> server.csr -CA ca.pem -CAkey ca-key.pem \</span><br><span class="line">  -CAcreateserial -out server-cert.pem -extfile extfile.cnf</span><br><span class="line">Signature ok</span><br><span class="line">subject=/CN=your.host.com</span><br><span class="line">Getting CA Private Key</span><br><span class="line">Enter pass phrase <span class="keyword">for</span> ca-key.pem:</span><br></pre></td></tr></table></figure>
<p>参考文档：<a href="https://docs.docker.com/engine/security/https/" target="_blank" rel="noopener">https://docs.docker.com/engine/security/https/</a></p>
<p>生成账号密码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir auth </span><br><span class="line">docker run --entrypoint htpasswd registry:2 -Bbn testuser testpassword &gt; auth/htpasswd</span><br></pre></td></tr></table></figure>

<p>用生成的证书和密钥启动Registry的服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 5000:5000 --restart=always --name registry \</span><br><span class="line">  -v `<span class="built_in">pwd</span>`/auth:/auth</span><br><span class="line">  -v `<span class="built_in">pwd</span>`/certs:/certs \</span><br><span class="line">  -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt \</span><br><span class="line">  -e REGISTRY_HTTP_TLS_KEY=/certs/domain.key \</span><br><span class="line">  registry:2</span><br></pre></td></tr></table></figure>

<h3 id="跨机器访问安全Registry"><a href="#跨机器访问安全Registry" class="headerlink" title="跨机器访问安全Registry"></a>跨机器访问安全Registry</h3><p>把Registry机器上生成的证书文件domain.crt拷贝到指定目录（取决于系统类型）：</p>
<ul>
<li>Ubuntu /etc/docker/certs.d/myregistrydomain.com:5000/ca.crt</li>
<li>Redhat系统 /etc/pki/ca-trust/source/anchors/myregistrydomain.com:5000.crt，并更新证书update-ca-trust</li>
</ul>
<p>然后重新启动Docker daemon的服务。<br>最后，可以push镜像了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull ubuntu</span><br><span class="line">docker tag ubuntu myregistrydomain.com:5000/ubuntu</span><br><span class="line">docker push myregistrydomain.com:5000/ubuntu</span><br><span class="line">docker pull myregistrydomain.com:5000/ubuntu</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>docker</category>
        <category>容器</category>
      </categories>
  </entry>
  <entry>
    <title>Docker容器log功能分析</title>
    <url>/2016/12/29/docker_log/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<h1 id="日志驱动"><a href="#日志驱动" class="headerlink" title="日志驱动"></a>日志驱动</h1><table>
<thead>
<tr>
<th>Driver</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>Disables any logging for the container. docker logs won’t be available with this driver.</td>
</tr>
<tr>
<td>json-file</td>
<td>Default logging driver for Docker. Writes JSON messages to file.</td>
</tr>
<tr>
<td>syslog</td>
<td>Syslog logging driver for Docker. Writes log messages to syslog.</td>
</tr>
<tr>
<td>journald</td>
<td>Journald logging driver for Docker. Writes log messages to journald.</td>
</tr>
<tr>
<td>gelf</td>
<td>Graylog Extended Log Format logging driver for Docker. Writes log messages to a GELF endpoint like Graylog or Logstash.</td>
</tr>
<tr>
<td>fluentd</td>
<td>Fluentd logging driver for Docker. Writes log messages to fluentd (forward input).</td>
</tr>
<tr>
<td>awslogs</td>
<td>Amazon CloudWatch Logs logging driver for Docker. Writes log messages to Amazon CloudWatch Logs.</td>
</tr>
<tr>
<td>splunk</td>
<td>Splunk logging driver for Docker. Writes log messages to splunk using HTTP Event Collector.</td>
</tr>
<tr>
<td>etwlogs</td>
<td>ETW logging driver for Docker on Windows. Writes log messages as ETW events.</td>
</tr>
<tr>
<td>gcplogs</td>
<td>Google Cloud Logging driver for Docker. Writes log messages to Google Cloud Logging.</td>
</tr>
</tbody></table>
<p>在daemon启动的时候可以配置日志驱动，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker daemon --<span class="built_in">log</span>-driver=json-file --<span class="built_in">log</span>-opt=map[]</span><br></pre></td></tr></table></figure>
<p>默认的驱动是json-file，可配置选项通过log-opt设置。<br>log-opt可选项如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--<span class="built_in">log</span>-opt max-size=[0-9+][k|m|g]</span><br><span class="line">--<span class="built_in">log</span>-opt max-file=[0-9+]</span><br><span class="line">--<span class="built_in">log</span>-opt labels=label1,label2</span><br><span class="line">--<span class="built_in">log</span>-opt env=env1,env2</span><br></pre></td></tr></table></figure>
<p>例如：<br>–log-opt max-size=2m限定日志文件的大小为2MB<br>–log-opt max-file=7限定日志文件最多7个<br>当日志文件超过2MB是，会写到第二个日志文件，如果日志文件超过7个时，会覆盖之前的日志文件。</p>
<h1 id="容器日志"><a href="#容器日志" class="headerlink" title="容器日志"></a>容器日志</h1><p>容器日志是容器在运行过程中产生的日志，默认会保存到/var/lib/docker/containers/CID/CID-json.log文件中。<br>可以用下面命令读取易读的日志：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker logs CID</span><br></pre></td></tr></table></figure>
<p>日志处理流程图如下：<br><img src="/images/docker_container_log1.png" alt="日志流程图"></p>
<h1 id="syslog驱动设置容器日志到单个日志文件"><a href="#syslog驱动设置容器日志到单个日志文件" class="headerlink" title="syslog驱动设置容器日志到单个日志文件"></a>syslog驱动设置容器日志到单个日志文件</h1><p>syslog驱动时，默认容器的日志都是输出到/var/log/messages文件中的，当需要把容器日志单独保存时，可以通过一些小办法实现。<br>步骤如下：</p>
<ul>
<li>设置容器日志的facility为一个特定值保证其他应用不会使用，例如：local5</li>
<li>配置一下rsyslog.cfg就好了，把local5的日志指定到一个文件中，例如：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">local5.*						 /var/<span class="built_in">log</span>/mydocker.log</span><br></pre></td></tr></table></figure>

<h1 id="Daemon挂掉时容器日志处理流程"><a href="#Daemon挂掉时容器日志处理流程" class="headerlink" title="Daemon挂掉时容器日志处理流程"></a>Daemon挂掉时容器日志处理流程</h1><p>当daemon挂掉时，容器的日志会缓存到上图的fifo中，fifo的默认大小是1M，可以通过如下命令获取：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat /proc/sys/fs/pipe-max-size</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>docker</category>
        <category>日志</category>
        <category>log</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu 14.04安装golang和liteide</title>
    <url>/2016/12/29/install_golang_liteide/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<h1 id="安装liteide"><a href="#安装liteide" class="headerlink" title="安装liteide"></a>安装liteide</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/visualfc/liteide.git</span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install qt4-dev-tools libqt4-dev libqt4-core libqt4-gui libqtwebkit-dev g++</span><br><span class="line">$ <span class="built_in">cd</span> liteide/build</span><br><span class="line">$ ./update_pkg.sh</span><br><span class="line">$ QTDIR=/usr ./build_linux.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">## Run it: ##</span></span><br><span class="line">$ <span class="built_in">cd</span> ~/liteide/build/liteide/bin</span><br><span class="line">$ ./liteide</span><br></pre></td></tr></table></figure>

<h1 id="安装golang"><a href="#安装golang" class="headerlink" title="安装golang"></a>安装golang</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://storage.googleapis.com/golang/go1.7.4.linux-amd64.tar.gz</span><br><span class="line">tar -C /usr/<span class="built_in">local</span> -xzf go<span class="variable">$VERSION</span>.<span class="variable">$OS</span>-<span class="variable">$ARCH</span>.tar.gz</span><br><span class="line">vi <span class="variable">$HOME</span>/.profile</span><br><span class="line">    &gt; <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/go/bin</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>liteide</category>
        <category>golang</category>
        <category>ide</category>
      </categories>
  </entry>
  <entry>
    <title>kiwi分析</title>
    <url>/2016/12/08/kiwi_analyse/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<h1 id="1-kiwi简介"><a href="#1-kiwi简介" class="headerlink" title="1. kiwi简介"></a>1. kiwi简介</h1><h2 id="1-1-kiwi是什么"><a href="#1-1-kiwi是什么" class="headerlink" title="1.1 kiwi是什么"></a>1.1 kiwi是什么</h2><p>kiwi用Perl编写的，用于制作linux镜像的命令行工具。支持制作多种格式的镜像：</p>
<ul>
<li>ISO</li>
<li>Live CD/DVD</li>
<li>PXEBoot</li>
<li>Hard Disk</li>
<li>USB</li>
<li>Amazon EC2 (.ami)</li>
<li>Docker</li>
<li>Google Cloud Format (..gce)</li>
<li>KVM/Qemu (.qcow2)</li>
<li>Open Virtualization Format (.ovf, .ova)</li>
<li>Vagrant (.vagrant</li>
<li>VirtualBox (.vdi)</li>
<li>Virtual Hard Disk (.vhd)</li>
<li>VMware (.vmdk)</li>
<li>XEN</li>
</ul>
<h2 id="1-2-kiwi工作流"><a href="#1-2-kiwi工作流" class="headerlink" title="1.2 kiwi工作流"></a>1.2 kiwi工作流</h2><p>kiwi的工作流分为两个流程：</p>
<ol>
<li>准备。创建root目录，用于保存新文件系统的内容；然后从软件源（可以是安装镜像或者在线的仓库）安装请求的软件包；然后创建镜像描述文件（config.xml）；<br>最后可选的自定义配置。该流程会输出一个“unpacked root tree”。</li>
<li>制作。kiwi会自动使用上个流程的输出制作镜像，此流程没有交互，但是可以通过修改image.sh脚本，实现在制作镜像过程中执行用户定义动作。</li>
</ol>
<h2 id="1-3-kiwi使用方法"><a href="#1-3-kiwi使用方法" class="headerlink" title="1.3 kiwi使用方法"></a>1.3 kiwi使用方法</h2><p>准备流程：kiwi –prepare<br>制作流程：kiwi –create</p>
<h1 id="2-kiwi的基本流程"><a href="#2-kiwi的基本流程" class="headerlink" title="2 kiwi的基本流程"></a>2 kiwi的基本流程</h1><p>kiwi制作镜像的流程是自动的，制作需要的必要信息主要来自config.xml的配置文件。此外，kiwi可以通过config.sh和images.sh实现可选的自定义功能。</p>
<h2 id="2-1-制作镜像"><a href="#2-1-制作镜像" class="headerlink" title="2.1 制作镜像"></a>2.1 制作镜像</h2><p>kiwi制作镜像分为两步。第一步，prepare操作，使用config.xml配置文件生成“unpacked image tree”。第二步，create操作，基于第一步生成的<br>“unpacked image”和config.xml配置文件提供的信息创建一个“packed image”（就是镜像）。</p>
<p><img src="https://doc.opensuse.org/projects/kiwi/doc/images/intro.png" alt="制作镜像架构图"></p>
<p>注：<br>    (1) Unpacked Image<br>        Encapsulated system reachable via chroot<br>    (2) Packed Image<br>        Encapsulated system reachable via kernel file system/extension drivers such as loopback mounts, etc. </p>
<h3 id="2-1-1-Prepare操作"><a href="#2-1-1-Prepare操作" class="headerlink" title="2.1.1 Prepare操作"></a>2.1.1 Prepare操作</h3><p>只有prepare操作成功，才能进行下一步的create操作。<br>prepare操作，kiwi会创建一个unpacked image（也就是root tree）。这个root tree是通过–root参数或者config.xml的defaultroot元素指定的。<br>该目录会在create操作中用于安装软件。软件管理工具是通过config.xml的packagemanager元素指定的，<br>kiwi目前支持的软件管理工具有：smart、zypper（默认选项）、yum和apt。<br>Prepare操作主要包括以下步骤：</p>
<ol>
<li>创建目标root目录。如果目标root目录存在，kiwi会退出并报错。可以使用–force-new-root参数，强制创建，如果指定目录存在，kiwi会先删除，<br>然后重新创建。</li>
<li>安装软件包。把配置文件的bootstrap部分指定的软件安装到root目录。filesystem和glibc-locale（euler没指定此包）包是构建引导环境<br>必需的软件。这两个包的依赖链足以在引导环境中填充所有必需的软件，以支持将软件包安装到新root目录中。软件包管理可能安装了一些不需要的软件包，<br>可以通过”<package type="delete">package_to_be_deleted</package>“来删除多余的软件包。</li>
<li>应用overlay目录。软件包安装完成后，KIWI将名为root的overlay目录中存在的所有文件和目录拷贝到目标root tree。<br>已经存在于目标root tree中的文件将被覆盖，其他将被添加。 这允许您覆盖在安装阶段期间软件包安装的任何文件。</li>
<li>安装archives。在上一步完成之后，把config.xml的archive元素指定的任何archive（可以使任何文件，以tar包形式保存），解开到目标root tree。<br>可能覆盖掉已有的文件。</li>
<li>运行用户定义的脚本config.sh。prepare操作的最后，执行config.sh脚本，运行在root tree的顶层。该脚本的主要功能是完成系统配置，例如启动一些服务。<br>更详细使用可参考 <a href="https://doc.opensuse.org/projects/kiwi/doc/#ref.kiwi.config.sh" target="_blank" rel="noopener">config.sh</a></li>
<li>管理新的root tree。你可以通过chroot操作新的root tree，此文件系统与常用的区别在于多一个image目录，用于保存kiwi在create步骤需要用到的信息，<br>例如，config.xml配置文件的副本。</li>
</ol>
<h3 id="2-1-2-Create操作"><a href="#2-1-2-Create操作" class="headerlink" title="2.1.2 Create操作"></a>2.1.2 Create操作</h3><p>Prepare操作的成功时Create操作的前提。保证unpacked root tree是完整的和一致的。create操作会创建一个packed image。利用unpacked root tree能够<br>创建多种类型image，例如，OEM image或者虚拟机的images。<br>Create操作主要执行以下步骤：</p>
<ol>
<li>运行用户自定义脚本images.sh。如果images.sh存在，首先在root tree的顶层执行此脚本。该脚本主要作用是删除最终镜像不需要的文件。<br>更详细使用方法可参考 <a href="https://doc.opensuse.org/projects/kiwi/doc/#ref.kiwi.images.sh" target="_blank" rel="noopener">images.sh</a></li>
<li>创建请求类型镜像。创建config.xml的type元素指定的image类型，配置文件必须包含至少一个type元素。下图显示当前支持的镜像类型。<br><img src="https://doc.opensuse.org/projects/kiwi/doc/images/types.png" alt="支持镜像类型"></li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
        <category>kiwi</category>
      </categories>
  </entry>
  <entry>
    <title>基于hexo和docker搭建静态网站环境</title>
    <url>/2016/12/07/docker_hexo/</url>
    <content><![CDATA[<hr>
<p>作者： 耗子007</p>
<hr>
<p>通过把hexo安装到docker容器中，然后在容器中启动hexo的服务。</p>
<h2 id="构建hexo的docker镜像"><a href="#构建hexo的docker镜像" class="headerlink" title="构建hexo的docker镜像"></a>构建hexo的docker镜像</h2><p>基于node的docker镜像制作我们的hexo镜像，主要做了如下几件事：</p>
<ul>
<li>配置代理（内网需要）</li>
<li>添加hexo工作目录</li>
<li>安装全局hexo</li>
<li>初始化hexo工作目录</li>
<li>暴露hexo服务的端口</li>
<li>在启动时，生成静态页面以及启动hexo服务</li>
</ul>
<p>Dockerfile如下所示：</p>
<pre>
<code>
    FROM node
    MAINTAINER Haozi007

    ENV http_proxy http://name:password@proxy:8080
    ENV https_proxy http://name:password@proxy:8080
    # Create hexo work dir
    WORKDIR /blog
    RUN npm install -g hexo-cli
    RUN hexo init /blog
    EXPOSE 4000

    CMD hexo generate && hexo server
</code>
</pre>

<p>制作docker镜像</p>
<pre><code>
    docker build -t haozi/hexo .
</code></pre>

<h2 id="启动hexo服务"><a href="#启动hexo服务" class="headerlink" title="启动hexo服务"></a>启动hexo服务</h2><p>可以通过docker的-v方法，把我们的markdown文档指定到容器中hexo的工作目录的source/_posts目录中，<br>这样当容器启动时，会自动生成对应的静态页面。<br>启动容器的命令如下：</p>
<pre><code>
    docker run --name hexo -itd -p 8088:4000 \
    -v /home/rtos/learning/workNotes/blogs:/blog/source/_posts \
    haozi/hexo
</code></pre>

<p>注：</p>
<ul>
<li>-p把容器的4000端口映射到host的8088端口，这样访问host的8088端口，就可以访问我们的hexo网站了。</li>
<li>-v把markdown写的文档，映射到hexo的工作目录下的_posts目录，这样我们可以方便的更新文档</li>
</ul>
<h2 id="网站维护"><a href="#网站维护" class="headerlink" title="网站维护"></a>网站维护</h2><p>可以把我们的所有markdown文档传到github或者其它内源保存。<br>每次更新文档的时候，有两种方法可以更新我们的hexo静态网站。</p>
<ul>
<li>只需要重启我们的hexo容器</li>
<li>执行docker exec -it hexo /bin/bash进入容器，然后到/blog目录，执行hexo generate就可以了</li>
</ul>
<p>前者需要重启容器，导致网站服务中断，后者比较麻烦，但是网站服务不好中断。 </p>
]]></content>
      <categories>
        <category>docker</category>
        <category>hexo</category>
      </categories>
  </entry>
</search>
